<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Bounce Ball RPG: The Legend</title>
    <link href="https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Do+Hyeon&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1e1e1e;
            font-family: 'Noto Sans KR', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container { width: 100vw; height: 100vh; display: block; }

        /* --- UI --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10; transition: opacity 0.5s;
        }
        body.cinematic #ui-layer { opacity: 0; }

        .letterbox {
            position: absolute; left: 0; width: 100%; height: 0;
            background: black; z-index: 20; transition: height 0.5s ease;
        }
        .letterbox.top { top: 0; }
        .letterbox.bottom { bottom: 0; }
        body.cinematic .letterbox { height: 12%; }

        .hud-panel {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px; border-radius: 15px;
            border: 2px solid #fff;
            color: #fff; font-family: 'Do Hyeon', sans-serif; font-size: 18px;
            display: flex; gap: 15px;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .quest-panel {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px; border-radius: 10px;
            border-left: 5px solid #f39c12;
            color: #fff; font-size: 15px; width: 240px;
            text-shadow: 1px 1px 0 #000;
            line-height: 1.4;
        }
        .quest-title { color: #f39c12; font-weight: bold; margin-bottom: 5px; font-size: 18px; font-family: 'Black Han Sans', sans-serif; }

        /* ì¡°ì´ìŠ¤í‹± ìŠ¤íƒ€ì¼ ìˆ˜ì • (transform ì œê±°) */
        #joystick-zone {
            position: absolute; 
            width: 140px; height: 140px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            pointer-events: auto; display: none;
            /* transform: translate(-50%, -50%); ì œê±° -> JSì—ì„œ ì§ì ‘ ì¢Œí‘œ ê³„ì‚° */
        }
        #joystick-knob {
            position: absolute; top: 50%; left: 50%;
            width: 60px; height: 60px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        #btn-interact {
            position: absolute; bottom: 50px; right: 50px;
            width: 90px; height: 90px;
            background: radial-gradient(circle, #f1c40f, #e67e22);
            border: 4px solid #fff; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.6);
            transform: scale(0); transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            pointer-events: auto; cursor: pointer; z-index: 50;
        }
        #btn-interact.visible { transform: scale(1); }
        #btn-interact::after { content: 'TALK'; font-weight: bold; font-size: 18px; color: #fff; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
        #btn-interact.shop::after { content: 'SHOP'; }

        /* ëŒ€í™”ì°½ */
        #dialogue-box {
            position: absolute; bottom: -300px; left: 50%; transform: translateX(-50%);
            width: 80%; max-width: 800px; height: 180px;
            background: rgba(20, 20, 20, 0.95);
            border: 3px solid #fff; border-radius: 15px;
            padding: 25px; box-sizing: border-box;
            color: #fff; z-index: 30;
            transition: bottom 0.4s ease;
            display: flex; flex-direction: column;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
        }
        body.cinematic #dialogue-box { bottom: 50px; }
        .npc-name { color: #f1c40f; font-weight: bold; font-size: 24px; margin-bottom: 10px; font-family: 'Do Hyeon', sans-serif; }
        .dialogue-text { font-size: 20px; line-height: 1.6; }
        .dialogue-next { align-self: flex-end; color: #aaa; font-size: 14px; margin-top: auto; animation: blink 1s infinite; }

        /* ìƒì  */
        .modal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: none; z-index: 100;
            justify-content: center; align-items: center; pointer-events: auto;
            backdrop-filter: blur(5px);
        }
        .shop-content {
            background: #fff; width: 450px; border-radius: 15px; padding: 30px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5); font-family: 'Do Hyeon', sans-serif;
            text-align: center; border: 4px solid #333;
        }
        .shop-item {
            background: #f0f0f0; margin: 15px 0; padding: 15px; border-radius: 10px;
            display: flex; justify-content: space-between; align-items: center;
            border: 1px solid #ccc;
        }
        .shop-desc { text-align: left; font-size: 18px; }
        .shop-desc small { color: #666; font-size: 14px; display: block; margin-top: 4px; }
        
        .shop-btn {
            background: #27ae60; color: white; border: none; padding: 10px 20px;
            border-radius: 8px; cursor: pointer; font-family: inherit; font-size: 18px;
            transition: background 0.2s;
        }
        .shop-btn:hover { background: #219150; }
        .shop-btn:active { transform: scale(0.95); }

        #toast {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.9); color: #f1c40f; padding: 12px 30px;
            border-radius: 30px; font-weight: bold; opacity: 0; transition: opacity 0.5s;
            pointer-events: none; font-size: 20px; z-index: 60; border: 1px solid #f1c40f;
        }

        @keyframes blink { 50% { opacity: 0; } }

        #touch-camera { position: absolute; top: 0; right: 0; width: 50%; height: 100%; pointer-events: auto; }
        #touch-move { position: absolute; top: 0; left: 0; width: 50%; height: 100%; pointer-events: auto; }
    </style>
</head>
<body>

    <div id="game-container"></div>

    <div class="letterbox top"></div>
    <div class="letterbox bottom"></div>

    <div id="ui-layer">
        <div class="hud-panel">
            <span>ğŸªµ <span id="res-wood">0</span></span>
            <span>ğŸª¨ <span id="res-stone">0</span></span>
            <span style="color:#f1c40f">ğŸ’° <span id="res-gold">0</span></span>
        </div>

        <div class="quest-panel">
            <div class="quest-title">ğŸ“œ í˜„ì¬ ëª©í‘œ</div>
            <div id="quest-desc">ì´Œì¥ë‹˜ê³¼ ëŒ€í™”í•˜ì—¬<br>ëª¨í—˜ì„ ì‹œì‘í•˜ì„¸ìš”.</div>
        </div>

        <div id="joystick-zone"><div id="joystick-knob"></div></div>
        <div id="btn-interact"></div>
        <div id="toast">ì•Œë¦¼</div>

        <div id="touch-move"></div>
        <div id="touch-camera"></div>
    </div>

    <!-- ëŒ€í™”ì°½ -->
    <div id="dialogue-box">
        <div class="npc-name" id="dial-name">Name</div>
        <div class="dialogue-text" id="dial-text">...</div>
        <div class="dialogue-next">í„°ì¹˜í•˜ì—¬ ê³„ì† â–¶</div>
    </div>

    <!-- ìƒì  UI -->
    <div id="shop-modal" class="modal-overlay">
        <div class="shop-content">
            <h2 style="margin-top:0; color:#e67e22; font-size: 32px;">ğŸ›’ ëª¨í—˜ê°€ ìƒì </h2>
            
            <div class="shop-item">
                <div class="shop-desc">
                    <strong>ìì› íŒë§¤</strong>
                    <small>ë‚˜ë¬´/ëŒ 5ê°œì”© â†’ 50 Gold</small>
                </div>
                <button class="shop-btn" onclick="game.shopSell()">íŒë§¤</button>
            </div>

            <div class="shop-item">
                <div class="shop-desc">
                    <strong>ì í”„ë ¥ ê°•í™”</strong> (200 Gold)
                    <small>ë†’ì€ ê³³ì— ë‹¿ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</small>
                </div>
                <button class="shop-btn" style="background:#e74c3c" onclick="game.shopUpgrade()">ê°•í™”</button>
            </div>

            <button class="shop-btn" style="background:#7f8c8d; width:100%; margin-top:10px;" onclick="game.closeShop()">ìƒì  ë‹«ê¸°</button>
        </div>
    </div>

    <!-- ì—”ë”© í™”ë©´ -->
    <div id="ending-screen" class="modal-overlay" style="background:black;">
        <div style="color:white; text-align:center;">
            <h1 style="color:#f1c40f; font-size:60px; margin-bottom:20px; font-family:'Black Han Sans';">THE END</h1>
            <p style="font-size:24px;">ì „ì„¤ì˜ ìš©ì‚¬ì—¬, ë§ˆì™•ì„ ë¬¼ë¦¬ì¹˜ê³  ì„¸ê³„ë¥¼ êµ¬í–ˆìŠµë‹ˆë‹¤!</p>
            <br><br>
            <button class="shop-btn" style="padding:15px 40px; font-size:20px;" onclick="location.reload()">ì²˜ìŒë¶€í„° ë‹¤ì‹œ í•˜ê¸°</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        class Game {
            constructor() {
                // ê²Œì„ ë°¸ëŸ°ìŠ¤ ì„¤ì •
                this.config = {
                    gravity: 0.018,
                    baseBounce: 0.40,
                    moveSpeed: 0.14,
                    ballRadius: 0.45
                };
                
                // í”Œë ˆì´ì–´ ë°ì´í„°
                this.stats = { jumpLevel: 0 };
                this.resources = { wood: 0, stone: 0, gold: 0 };
                this.questState = 0; 
                
                // Three.js
                this.scene = null; this.camera = null; this.renderer = null;
                this.ball = null; this.ballShadow = null;
                
                this.colliders = [];
                this.interactables = [];
                this.textures = {}; 
                
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.input = { x: 0, z: 0 };
                this.cameraState = { yaw: 0, pitch: 0.6, dist: 14 };
                
                this.activeNPC = null;
                this.inCutscene = false;
                this.typingTimer = null;

                // UI Elements
                this.ui = {
                    wood: document.getElementById('res-wood'),
                    stone: document.getElementById('res-stone'),
                    gold: document.getElementById('res-gold'),
                    quest: document.getElementById('quest-desc'),
                    toast: document.getElementById('toast'),
                    interactBtn: document.getElementById('btn-interact'),
                    dialogueBox: document.getElementById('dialogue-box'),
                    dialName: document.getElementById('dial-name'),
                    dialText: document.getElementById('dial-text')
                };

                this.init();
            }

            init() {
                // 1. Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 20, 150);

                // 2. Camera
                this.camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 500);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('game-container').appendChild(this.renderer.domElement);

                // 3. Light
                const ambient = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambient);
                const sun = new THREE.DirectionalLight(0xffffff, 0.8);
                sun.position.set(50, 100, 50);
                sun.castShadow = true;
                sun.shadow.mapSize.width = 4096;
                sun.shadow.mapSize.height = 4096;
                this.scene.add(sun);

                // 4. World Build
                this.generateTextures();
                this.createPlayer();
                this.buildWorld(); // ë§µ ìƒì„±
                this.setupInputs();

                // 5. Intro
                this.startCutscene([
                    { name: "ì‹œìŠ¤í…œ", text: "ë°”ìš´ìŠ¤ ì›”ë“œì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤." },
                    { name: "ì‹œìŠ¤í…œ", text: "ë§ˆì„ ì¤‘ì•™ì— ìˆëŠ” ì´Œì¥ë‹˜ì„ ë§Œë‚˜ í€˜ìŠ¤íŠ¸ë¥¼ ë°›ìœ¼ì„¸ìš”." }
                ]);

                this.animate();
                window.addEventListener('resize', () => this.onResize());
            }

            // --- í…ìŠ¤ì²˜ ìƒì„± (Procedural) ---
            generateTextures() {
                this.textures.grass = this.createTexture('#4CAF50', '#388E3C', 'noise');
                this.textures.stone = this.createTexture('#9E9E9E', '#757575', 'noise');
                this.textures.wood = this.createTexture('#8D6E63', '#5D4037', 'lines');
                this.textures.lava = this.createTexture('#E74C3C', '#C0392B', 'noise');
            }

            createTexture(c1, c2, type) {
                const cvs = document.createElement('canvas');
                cvs.width = 128; cvs.height = 128;
                const ctx = cvs.getContext('2d');
                ctx.fillStyle = c1; ctx.fillRect(0,0,128,128);
                if(type === 'noise') {
                    for(let i=0; i<1000; i++) {
                        ctx.fillStyle = c2;
                        ctx.fillRect(Math.random()*128, Math.random()*128, 2, 2);
                    }
                } else {
                    ctx.strokeStyle = c2; ctx.lineWidth = 2;
                    for(let i=0; i<10; i++) {
                        ctx.beginPath();
                        ctx.moveTo(0, Math.random()*128);
                        ctx.lineTo(128, Math.random()*128);
                        ctx.stroke();
                    }
                }
                const tex = new THREE.CanvasTexture(cvs);
                tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
                return tex;
            }

            // --- í”Œë ˆì´ì–´ ---
            createPlayer() {
                const geo = new THREE.SphereGeometry(this.config.ballRadius, 32, 32);
                const mat = new THREE.MeshPhongMaterial({ color: 0xFF5722, shininess: 80 });
                this.ball = new THREE.Mesh(geo, mat);
                this.ball.position.set(0, 5, 0);
                this.ball.castShadow = true;
                this.scene.add(this.ball);

                const sGeo = new THREE.CircleGeometry(this.config.ballRadius, 16);
                const sMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 });
                this.ballShadow = new THREE.Mesh(sGeo, sMat);
                this.ballShadow.rotation.x = -Math.PI/2;
                this.scene.add(this.ballShadow);
            }

            // --- ë ˆë²¨ ë””ìì¸ (ë§µ ë¶„ë¦¬) ---
            buildWorld() {
                // 1. ì‹œì‘ ë§ˆì„ (Z: 0)
                this.createPlatform(0, 0, 0, 30, 30, 'grass'); 
                this.createHouse(8, 0, 5, 0xf1c40f);
                this.createHouse(-8, 0, 8, 0xe67e22);
                this.createNPC(5, 0, 5, 'chief', 'ì´Œì¥', 0x3498db);
                this.createNPC(-5, 0, 8, 'shop', 'ìƒì¸', 0x9b59b6);
                
                // ë§ˆì„ ìì›
                for(let i=0; i<5; i++) {
                    this.createResource((Math.random()-0.5)*20, 0, (Math.random()-0.5)*20, 'wood');
                    this.createResource((Math.random()-0.5)*20, 0, (Math.random()-0.5)*20, 'stone');
                }

                // 2. ë‹¤ë¦¬ (ë§ˆì„ -> ìˆ²) (Z: -30 ~ -80)
                // ë‹¤ë¦¬ ê°„ê²© ì¢í˜ (i * 5) -> ì‰½ê²Œ ê±´ë„ ìˆ˜ ìˆìŒ
                this.createBridge(0, 0, -30, 10); 

                // 3. ìˆ² (Z: -100)
                this.createPlatform(0, 0, -100, 25, 25, 'grass');
                this.createResource(0, 0, -100, 'wood'); // ì¤‘ì•™ ë‚˜ë¬´
                for(let i=0; i<8; i++) {
                    const x = (Math.random()-0.5)*20; 
                    const z = -100 + (Math.random()-0.5)*20;
                    this.createResource(x, 0, z, Math.random()>0.5 ? 'wood':'stone');
                }
                
                // ìˆ²ì˜ ë†’ì€ ì§€í˜• (íŒŒì¿ ë¥´)
                this.createPlatform(10, 4, -100, 5, 5, 'stone');
                this.createPlatform(-10, 8, -100, 5, 5, 'stone');
                this.createPlatform(0, 12, -110, 5, 5, 'stone');

                // 4. ë‹¤ë¦¬ (ìˆ² -> ë§ˆì™•ì„±) (Z: -130 ~ -180)
                this.createPlatform(0, 12, -130, 3, 3, 'stone');
                this.createPlatform(0, 12, -150, 3, 3, 'stone');
                this.createPlatform(0, 12, -170, 3, 3, 'stone');

                // 5. ë§ˆì™•ì„± (Z: -200)
                this.createPlatform(0, 12, -200, 20, 20, 'stone');
                this.createNPC(0, 12, -200, 'boss', 'ë§ˆì™•', 0xe74c3c);
                
                // ìš©ì•” ë°ì½”
                for(let i=0; i<20; i++) {
                    const m = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.8,0.8), new THREE.MeshLambertMaterial({map:this.textures.lava}));
                    m.position.set((Math.random()-0.5)*15, 12.5, -200+(Math.random()-0.5)*15);
                    this.scene.add(m);
                }

                // ë°”ë‹¤ (ë‚™ì‚¬)
                const sea = new THREE.Mesh(
                    new THREE.PlaneGeometry(800, 800),
                    new THREE.MeshBasicMaterial({ color: 0x1E90FF, transparent:true, opacity:0.6 })
                );
                sea.rotation.x = -Math.PI/2; sea.position.y = -20;
                this.scene.add(sea);
            }

            createPlatform(x, y, z, w, d, texName) {
                const tex = this.textures[texName];
                const mat = new THREE.MeshLambertMaterial({ map: tex });
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, 1, d), mat);
                // ìœ—ë©´ì´ yì— ì˜¤ë„ë¡ (y-0.5)
                mesh.position.set(x, y - 0.5, z);
                mesh.receiveShadow = true;
                this.scene.add(mesh);
                
                const box = new THREE.Box3().setFromObject(mesh);
                mesh.userData = { type: 'ground', box: box };
                this.colliders.push(mesh);
            }

            createBridge(x, y, z, length) {
                const mat = new THREE.MeshLambertMaterial({ map: this.textures.wood });
                for(let i=0; i<length; i++) {
                    const mesh = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 4), mat);
                    // ê°„ê²©ì„ ì¢í˜€ì„œ ì‰½ê²Œ ë§Œë“¦ (z spacing 5, length 4 = gap 1)
                    mesh.position.set(x, y, z - (i * 5)); 
                    mesh.receiveShadow = true;
                    this.scene.add(mesh);
                    const box = new THREE.Box3().setFromObject(mesh);
                    mesh.userData = { type: 'ground', box: box };
                    this.colliders.push(mesh);
                }
            }

            createHouse(x, y, z, color) {
                const base = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 4), new THREE.MeshLambertMaterial({color}));
                base.position.set(x, y+1.5, z);
                base.castShadow = true;
                this.scene.add(base);
                this.colliders.push(base);
                const roof = new THREE.Mesh(new THREE.ConeGeometry(3.5, 2, 4), new THREE.MeshLambertMaterial({color:0x8B0000}));
                roof.position.set(x, y+4, z); roof.rotation.y = Math.PI/4;
                this.scene.add(roof);
            }

            createNPC(x, y, z, id, name, color) {
                const group = new THREE.Group();
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.5, 12), new THREE.MeshLambertMaterial({color}));
                body.position.y = 0.75;
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshLambertMaterial({color:0xffe0bd}));
                head.position.y = 1.6;
                group.add(body); group.add(head);
                if(id === 'boss') { group.scale.set(2, 2, 2); head.material.color.setHex(0x000000); }
                
                group.position.set(x, y, z); 
                group.castShadow = true;
                this.scene.add(group);
                
                group.userData = { type: 'npc', id, name };
                this.interactables.push(group);
                
                const box = new THREE.Box3().setFromObject(group);
                group.userData.box = box;
                this.colliders.push(group);
            }

            createResource(x, y, z, type) {
                let mesh;
                if(type === 'wood') {
                    mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 2, 8), new THREE.MeshLambertMaterial({map: this.textures.wood}));
                    const leaves = new THREE.Mesh(new THREE.ConeGeometry(1.2, 2, 8), new THREE.MeshLambertMaterial({color:0x2E7D32}));
                    leaves.position.y = 1.5;
                    mesh.add(leaves);
                    mesh.position.set(x, y+1, z);
                } else {
                    mesh = new THREE.Mesh(new THREE.DodecahedronGeometry(0.7), new THREE.MeshLambertMaterial({map: this.textures.stone}));
                    mesh.position.set(x, y+0.7, z);
                }
                mesh.castShadow = true;
                this.scene.add(mesh);
                
                const box = new THREE.Box3().setFromObject(mesh);
                mesh.userData = { type: 'resource', resType: type, box: box };
                this.colliders.push(mesh);
            }

            // --- ë¬¼ë¦¬ ë° ì¶©ëŒ ---
            updatePhysics() {
                // ì¤‘ë ¥
                this.velocity.y -= this.config.gravity;
                this.ball.position.add(this.velocity);

                // ì´ë™
                const cy = this.cameraState.yaw;
                const tx = (this.input.x * Math.cos(cy) + this.input.z * Math.sin(cy)) * this.config.moveSpeed;
                const tz = (this.input.x * -Math.sin(cy) + this.input.z * Math.cos(cy)) * this.config.moveSpeed;
                this.velocity.x += (tx - this.velocity.x) * 0.15;
                this.velocity.z += (tz - this.velocity.z) * 0.15;

                // ì¶©ëŒ ì²´í¬ (5ì  ë ˆì´ìºìŠ¤íŠ¸)
                const r = this.config.ballRadius * 0.8;
                const origins = [
                    new THREE.Vector3(0,0,0), new THREE.Vector3(r,0,0), new THREE.Vector3(-r,0,0),
                    new THREE.Vector3(0,0,r), new THREE.Vector3(0,0,-r)
                ];
                let groundY = -999;
                let hitObj = null;
                const raycaster = new THREE.Raycaster();
                const down = new THREE.Vector3(0, -1, 0);

                for(let o of origins) {
                    const origin = this.ball.position.clone().add(o);
                    raycaster.set(origin, down);
                    // ê°€ê¹Œìš´ ë¬¼ì²´ë§Œ ì²´í¬
                    const intersects = raycaster.intersectObjects(this.colliders);
                    if(intersects.length > 0) {
                        const hit = intersects[0];
                        if(hit.distance < this.config.ballRadius + 0.2 && hit.point.y > groundY) {
                            groundY = hit.point.y;
                            hitObj = hit.object;
                        }
                    }
                }

                // ë°”ë‹¥ ì°©ì§€
                if (this.velocity.y < 0 && this.ball.position.y <= groundY + this.config.ballRadius + 0.1) {
                    // ì í”„ë ¥ (ê¸°ë³¸ + ë ˆë²¨ë‹¹ ì¦ê°€)
                    const jumpPower = this.config.baseBounce + (this.stats.jumpLevel * 0.15);
                    this.velocity.y = jumpPower;
                    this.ball.position.y = groundY + this.config.ballRadius;
                    
                    // ìì› ì±„ì§‘
                    if(hitObj && hitObj.userData.type === 'resource') {
                        this.gatherResource(hitObj);
                    }
                }

                // ê·¸ë¦¼ì
                if(groundY > -100) {
                    this.ballShadow.position.set(this.ball.position.x, groundY+0.02, this.ball.position.z);
                    this.ballShadow.visible = true;
                } else {
                    this.ballShadow.visible = false;
                }

                // ë‚™ì‚¬ ë¦¬ìŠ¤í°
                if(this.ball.position.y < -30) {
                    this.respawn();
                }

                // ê³µ íšŒì „
                this.ball.rotation.x -= this.velocity.z * 1.5;
                this.ball.rotation.z += this.velocity.x * 1.5;

                this.checkInteractions();
            }

            respawn() {
                this.velocity.set(0, 0, 0);
                // ì§„í–‰ë„ì— ë”°ë¼ ë¦¬ìŠ¤í° ìœ„ì¹˜ ë³€ê²½
                if(this.ball.position.z < -180) this.ball.position.set(0, 15, -130);
                else if(this.ball.position.z < -80) this.ball.position.set(0, 5, -50);
                else this.ball.position.set(0, 5, 0);
                this.showToast("êµ¬ì¡°ë˜ì—ˆìŠµë‹ˆë‹¤!");
            }

            // --- ìƒí˜¸ì‘ìš© ë° í€˜ìŠ¤íŠ¸ ---
            checkInteractions() {
                let closest = null;
                let minDist = 7; 
                this.interactables.forEach(npc => {
                    const dist = this.ball.position.distanceTo(npc.position);
                    if(dist < minDist) {
                        minDist = dist;
                        closest = npc;
                    }
                });

                if(closest !== this.activeNPC) {
                    this.activeNPC = closest;
                    const btn = this.ui.interactBtn;
                    if(closest) {
                        btn.classList.add('visible');
                        btn.className = closest.userData.id === 'shop' ? 'shop' : '';
                        btn.classList.add('visible');
                    } else {
                        btn.classList.remove('visible');
                    }
                }
            }

            interact() {
                if(this.inCutscene || !this.activeNPC) return;
                const id = this.activeNPC.userData.id;
                
                if(id === 'shop') {
                    document.getElementById('shop-modal').style.display = 'flex';
                    this.inCutscene = true;
                } else if(id === 'chief') {
                    this.runQuestLogic();
                } else if(id === 'boss') {
                    document.getElementById('ending-screen').style.display = 'flex';
                    this.inCutscene = true;
                }
            }

            runQuestLogic() {
                const lines = [];
                // í€˜ìŠ¤íŠ¸ ìƒíƒœ ê´€ë¦¬
                if(this.questState === 0) {
                    lines.push({name:'ì´Œì¥', text:"ìë„¤ê°€ ì „ì„¤ì˜ ìš©ì‚¬ì¸ê°€? ë§ˆì™•ì´ ë¶€í™œí–ˆë„¤."});
                    lines.push({name:'ì´Œì¥', text:"í•˜ì§€ë§Œ ì§€ê¸ˆì€ ë„ˆë¬´ ì•½í•´. ìì›ì„ ëª¨ì•„ ìƒì ì—ì„œ 'ì í”„ë ¥'ì„ ê°•í™”í•˜ê²Œ."});
                    this.questState = 1;
                    this.ui.quest.innerHTML = "ìì›ì„ ëª¨ì•„ ìƒì ì—ì„œ<br>ì í”„ë ¥ì„ ê°•í™”í•˜ì„¸ìš”.";
                } else if(this.questState === 1) {
                    if(this.stats.jumpLevel > 0) {
                        lines.push({name:'ì´Œì¥', text:"ì˜¤! í˜ì´ ëŠê»´ì§€ëŠ”êµ°. ì´ì œ ë¶ìª½ ìˆ²ì„ ì§€ë‚˜ ë§ˆì™•ì„±ìœ¼ë¡œ ê°ˆ ìˆ˜ ìˆê² ì–´!"});
                        this.questState = 2;
                        this.ui.quest.innerHTML = "ë¶ìª½ ìˆ²ì„ ì§€ë‚˜<br>ë§ˆì™•ì„ ë¬¼ë¦¬ì¹˜ì„¸ìš”!";
                    } else {
                        lines.push({name:'ì´Œì¥', text:"ì•„ì§ì¼ì„¸. ìƒì ì—ì„œ ê°•í™”ë¥¼ í•´ì•¼ ë‹¤ë¦¬ë¥¼ ê±´ë„ ìˆ˜ ìˆì–´."});
                    }
                } else {
                    lines.push({name:'ì´Œì¥', text:"ë§ˆì™•ì„ ê¼­ ë¬¼ë¦¬ì³ ì£¼ê²Œ!"});
                }
                this.startDialogue(lines);
            }

            // --- ìƒì  ê¸°ëŠ¥ ---
            shopSell() {
                if(this.resources.wood >= 5 && this.resources.stone >= 5) {
                    this.resources.wood -= 5;
                    this.resources.stone -= 5;
                    this.resources.gold += 50;
                    this.updateHUD();
                    this.showToast("ìì›ì„ íŒ”ì•„ 50G íšë“!");
                } else {
                    this.showToast("ë‚˜ë¬´ì™€ ëŒì´ 5ê°œì”© í•„ìš”í•©ë‹ˆë‹¤.");
                }
            }

            shopUpgrade() {
                if(this.resources.gold >= 200) {
                    this.resources.gold -= 200;
                    this.stats.jumpLevel++;
                    this.updateHUD();
                    this.showToast("ì í”„ë ¥ ê°•í™” ì™„ë£Œ!");
                    
                    // í€˜ìŠ¤íŠ¸ ì¡°ê±´ ì¶©ì¡± ì•Œë¦¼
                    if(this.questState === 1) {
                        this.ui.quest.innerHTML = "ì´Œì¥ë‹˜ê»˜ ëŒì•„ê°€ì„¸ìš”!";
                        this.showToast("í€˜ìŠ¤íŠ¸ ì¡°ê±´ ë‹¬ì„±!");
                    }
                } else {
                    this.showToast("ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤ (200G)");
                }
            }

            gatherResource(obj) {
                const type = obj.userData.resType;
                if(!type) return;
                
                if(type === 'wood') this.resources.wood++;
                else this.resources.stone++;
                
                this.updateHUD();
                this.showToast(`${type.toUpperCase()} íšë“!`);
                
                // ì„ì‹œ ì œê±°
                obj.position.y -= 100;
                setTimeout(() => { obj.position.y += 100; }, 3000);
            }

            // --- ì‹œê° íš¨ê³¼ ---
            updateHUD() {
                this.ui.wood.innerText = this.resources.wood;
                this.ui.stone.innerText = this.resources.stone;
                this.ui.gold.innerText = this.resources.gold;
            }

            showToast(msg) {
                const t = this.ui.toast;
                t.innerText = msg;
                t.style.opacity = 1;
                setTimeout(() => t.style.opacity = 0, 2000);
            }

            closeShop() { document.getElementById('shop-modal').style.display = 'none'; this.inCutscene = false; }

            // --- ëŒ€í™” ì‹œìŠ¤í…œ (ì¤‘ë³µ ë°©ì§€) ---
            startCutscene(lines) {
                this.inCutscene = true;
                document.body.classList.add('cinematic');
                this.input.x = 0; this.input.z = 0;
                this.startDialogue(lines, () => {
                    document.body.classList.remove('cinematic');
                    this.inCutscene = false;
                });
            }

            startDialogue(lines, onComplete) {
                if(this.typingTimer) clearTimeout(this.typingTimer);
                const box = this.ui.dialogueBox;
                const nameEl = this.ui.dialName;
                const textEl = this.ui.dialText;
                let index = 0;
                let isTyping = false;
                let currentText = "";

                box.style.bottom = '50px';

                const next = () => {
                    if(isTyping) {
                        // ìŠ¤í‚µ ê¸°ëŠ¥
                        clearTimeout(this.typingTimer);
                        textEl.innerHTML = currentText;
                        isTyping = false;
                        return;
                    }

                    if(index >= lines.length) {
                        box.style.bottom = '-300px';
                        box.onclick = null;
                        if(onComplete) onComplete();
                        else this.inCutscene = false;
                        return;
                    }

                    const line = lines[index++];
                    nameEl.innerText = line.name;
                    textEl.innerHTML = "";
                    currentText = line.text;
                    isTyping = true;

                    let charIdx = 0;
                    const type = () => {
                        if(charIdx < currentText.length) {
                            textEl.innerHTML += currentText.charAt(charIdx++);
                            this.typingTimer = setTimeout(type, 30);
                        } else {
                            isTyping = false;
                        }
                    };
                    type();
                };

                box.onclick = next;
                this.inCutscene = true;
                next();
            }

            // --- ì…ë ¥ ---
            setupInputs() {
                const joyZone = document.getElementById('joystick-zone');
                const joyKnob = document.getElementById('joystick-knob');
                let joyId = null, startX=0, startY=0;

                const touchMove = document.getElementById('touch-move');
                touchMove.addEventListener('touchstart', e => {
                    e.preventDefault(); if(this.inCutscene) return;
                    const t = e.changedTouches[0]; joyId = t.identifier;
                    startX = t.clientX; startY = t.clientY;
                    joyZone.style.display = 'block';
                    
                    // ì¡°ì´ìŠ¤í‹± ë³´ì • (í„°ì¹˜ ì§€ì  ì¤‘ì‹¬)
                    joyZone.style.left = (startX - 70) + 'px';
                    joyZone.style.top = (startY - 70) + 'px';
                    
                    joyKnob.style.transform = `translate(-50%, -50%)`;
                    this.input.x = 0; this.input.z = 0;
                }, {passive:false});

                touchMove.addEventListener('touchmove', e => {
                    e.preventDefault(); if(this.inCutscene) return;
                    for(let i=0; i<e.changedTouches.length; i++) {
                        if(e.changedTouches[i].identifier === joyId) {
                            const t = e.changedTouches[i];
                            const dx = t.clientX - startX; const dy = t.clientY - startY;
                            const dist = Math.min(Math.sqrt(dx*dx+dy*dy), 50);
                            const angle = Math.atan2(dy, dx);
                            const mx = Math.cos(angle)*dist; const my = Math.sin(angle)*dist;
                            joyKnob.style.transform = `translate(calc(-50% + ${mx}px), calc(-50% + ${my}px))`;
                            this.input.x = mx/50; this.input.z = my/50;
                        }
                    }
                }, {passive:false});

                const endJoy = (e) => {
                    for(let i=0; i<e.changedTouches.length; i++) {
                        if(e.changedTouches[i].identifier === joyId) {
                            joyId = null; joyZone.style.display = 'none';
                            this.input.x = 0; this.input.z = 0;
                        }
                    }
                };
                touchMove.addEventListener('touchend', endJoy); 
                touchMove.addEventListener('touchcancel', endJoy);

                // ì¹´ë©”ë¼ & ìƒí˜¸ì‘ìš© (ìƒí•˜ì¢Œìš° ììœ  ì‹œì )
                let lastCamX = 0, lastCamY = 0;
                const touchCam = document.getElementById('touch-camera');
                
                touchCam.addEventListener('touchstart', e => {
                    if(e.target.closest('#btn-interact')) return;
                    e.preventDefault(); 
                    lastCamX = e.changedTouches[0].clientX;
                    lastCamY = e.changedTouches[0].clientY;
                }, {passive:false});

                touchCam.addEventListener('touchmove', e => {
                    if(e.target.closest('#btn-interact')) return;
                    e.preventDefault(); if(this.inCutscene) return;
                    
                    const t = e.changedTouches[0];
                    const dx = t.clientX - lastCamX;
                    const dy = t.clientY - lastCamY;
                    
                    // ì¢Œìš° íšŒì „ (Yaw)
                    this.cameraState.yaw -= dx * 0.005;
                    
                    // ìƒí•˜ íšŒì „ (Pitch) - ì œí•œ ì ìš© (0.1 ~ 1.5 ë¼ë””ì•ˆ)
                    this.cameraState.pitch += dy * 0.005;
                    this.cameraState.pitch = Math.max(0.1, Math.min(1.5, this.cameraState.pitch));

                    lastCamX = t.clientX;
                    lastCamY = t.clientY;
                }, {passive:false});

                this.ui.interactBtn.addEventListener('click', e => { e.stopPropagation(); this.interact(); });
                this.ui.interactBtn.addEventListener('touchstart', e => { e.stopPropagation(); this.interact(); });

                // PC Key
                document.addEventListener('keydown', e => {
                    if(this.inCutscene) return;
                    switch(e.key.toLowerCase()) {
                        case 'w': this.input.z = -1; break;
                        case 's': this.input.z = 1; break;
                        case 'a': this.input.x = -1; break;
                        case 'd': this.input.x = 1; break;
                        case 'e': this.interact(); break;
                    }
                });
                document.addEventListener('keyup', e => {
                    if(['w','s'].includes(e.key.toLowerCase())) this.input.z = 0;
                    if(['a','d'].includes(e.key.toLowerCase())) this.input.x = 0;
                });

                // PC ë§ˆìš°ìŠ¤ ì‹œì  ì¡°ì‘ ì¶”ê°€
                let isMouseDown = false;
                document.addEventListener('mousedown', e => {
                    if(this.inCutscene || e.target.closest('#btn-interact') || e.target.closest('.modal-overlay')) return;
                    isMouseDown = true;
                    lastCamX = e.clientX;
                    lastCamY = e.clientY;
                });

                document.addEventListener('mousemove', e => {
                    if(!isMouseDown || this.inCutscene) return;
                    const dx = e.clientX - lastCamX;
                    const dy = e.clientY - lastCamY;
                    
                    this.cameraState.yaw -= dx * 0.005;
                    this.cameraState.pitch += dy * 0.005;
                    this.cameraState.pitch = Math.max(0.1, Math.min(1.5, this.cameraState.pitch));
                    
                    lastCamX = e.clientX;
                    lastCamY = e.clientY;
                });

                document.addEventListener('mouseup', () => isMouseDown = false);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                if (!this.inCutscene) this.updatePhysics();
                else this.ball.position.y = 2 + Math.sin(Date.now()*0.002)*0.2;

                const cx = this.ball.position.x + this.cameraState.dist * Math.cos(this.cameraState.pitch) * Math.sin(this.cameraState.yaw);
                const cz = this.ball.position.z + this.cameraState.dist * Math.cos(this.cameraState.pitch) * Math.cos(this.cameraState.yaw);
                const cy = this.ball.position.y + this.cameraState.dist * Math.sin(this.cameraState.pitch);
                
                this.camera.position.lerp(new THREE.Vector3(cx, cy, cz), 0.1);
                this.camera.lookAt(this.ball.position);
                
                this.renderer.render(this.scene, this.camera);
            }

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        const game = new Game();
    </script>
</body>
</html>
