<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Bounce Ball RPG: Legend of Hero</title>
    <link href="https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Jua&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Jua', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* --- UI ë ˆì´ì–´ --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* ìƒë‹¨ ìì›ë°” */
        .resource-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 30px;
            border-radius: 50px;
            color: white;
            font-size: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            border: 2px solid #FFD700;
        }

        /* í€˜ìŠ¤íŠ¸ ì•Œë¦¼ */
        #quest-box {
            position: absolute;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 16px;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        /* ì¡°ì´ìŠ¤í‹± (ì¢Œì¸¡ í•˜ë‹¨) */
        #joystick-base {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            display: none;
            pointer-events: none;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(255,255,255,0.2);
        }

        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        /* ìƒí˜¸ì‘ìš© ë²„íŠ¼ (ìš°ì¸¡ í•˜ë‹¨ ê³ ì •) */
        #btn-interact-action {
            position: absolute;
            bottom: 50px;
            right: 50px;
            width: 90px;
            height: 90px;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            border: 4px solid #FFF;
            border-radius: 50%;
            font-size: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 8px 0 #b8860b, 0 15px 20px rgba(0,0,0,0.4);
            pointer-events: auto; /* í„°ì¹˜ ê°€ëŠ¥ */
            transition: transform 0.1s, opacity 0.2s;
            opacity: 0.5; /* í‰ì†Œì—” ë°˜íˆ¬ëª… */
            cursor: pointer;
        }

        #btn-interact-action.active {
            opacity: 1;
            transform: scale(1.1);
            animation: pulse 1s infinite;
        }
        
        #btn-interact-action:active {
            transform: scale(0.95) translateY(4px);
            box-shadow: 0 4px 0 #b8860b;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(255, 215, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
        }

        /* ëŒ€í™”ì°½ & ëª¨ë‹¬ */
        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fff;
            padding: 30px;
            border-radius: 20px;
            width: 80%;
            max-width: 400px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.6);
            display: none;
            pointer-events: auto;
            text-align: center;
            color: #333;
            z-index: 100;
            border: 5px solid #8B4513;
        }

        .modal h2 { margin-top: 0; color: #8B4513; border-bottom: 2px dashed #D2691E; padding-bottom: 15px; font-family: 'Black Han Sans', sans-serif; font-size: 32px; }
        .modal p { font-size: 20px; line-height: 1.6; color: #555; margin: 20px 0; }

        .btn-modal {
            background: #8B4513;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 18px;
            font-family: 'Jua', sans-serif;
            margin-top: 10px;
        }

        /* ì•Œë¦¼ ë©”ì‹œì§€ */
        #toast {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: #FFD700;
            padding: 12px 30px;
            border-radius: 30px;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            font-size: 18px;
            z-index: 50;
        }

        /* í„°ì¹˜ ì˜ì—­ */
        #touch-left { position: absolute; top: 0; left: 0; width: 50%; height: 100%; pointer-events: auto; }
        #touch-right { position: absolute; top: 0; right: 0; width: 50%; height: 100%; pointer-events: auto; }

    </style>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div class="resource-bar">
            <span>ğŸªµ <span id="res-wood">0</span></span>
            <span>ğŸª¨ <span id="res-stone">0</span></span>
            <span>ğŸ’° <span id="res-gold">0</span></span>
        </div>
        
        <div id="quest-box">ğŸ“œ í˜„ì¬ ëª©í‘œ: ì´Œì¥ë‹˜ì„ ë§Œë‚˜ì„¸ìš”!</div>
        <div id="toast">ì•Œë¦¼</div>

        <!-- ì¡°ì´ìŠ¤í‹± -->
        <div id="joystick-base">
            <div id="joystick-knob"></div>
        </div>

        <!-- ìƒí˜¸ì‘ìš© ë²„íŠ¼ -->
        <div id="btn-interact-action">âœ‹</div>

        <!-- í„°ì¹˜ ì˜ì—­ -->
        <div id="touch-left"></div>
        <div id="touch-right"></div>
    </div>

    <!-- ëŒ€í™”ì°½ -->
    <div id="dialogue-modal" class="modal">
        <h2 id="npc-name">NPC</h2>
        <p id="npc-text">ëŒ€í™” ë‚´ìš©</p>
        <button class="btn-modal" onclick="game.closeDialogue()">í™•ì¸</button>
    </div>

    <!-- ìƒì  -->
    <div id="shop-modal" class="modal">
        <h2>ğŸ’° ëª¨í—˜ê°€ ìƒì </h2>
        <div style="text-align:left; margin-bottom: 20px;">
            <p>1. ìì› íŒë§¤ (ê° 5ê°œ â†’ 30G)<br>
            <button class="btn-modal" style="background:#2ecc71; width:100%" onclick="game.sellResources()">íŒë§¤í•˜ê¸°</button></p>
            
            <p>2. ìš©ì‚¬ì˜ í˜ ê°•í™” (100G)<br>
            <span style="font-size:14px; color:#666">* ì í”„ë ¥ì´ ìƒìŠ¹í•˜ì—¬ ë§ˆì™•ì„±ì— ê°ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</span>
            <button class="btn-modal" style="background:#e74c3c; width:100%" onclick="game.upgradeJump()">ê°•í™”í•˜ê¸°</button></p>
        </div>
        <button class="btn-modal" style="background:#95a5a6" onclick="game.closeShop()">ë‚˜ê°€ê¸°</button>
    </div>

    <!-- ì—”ë”© í™”ë©´ -->
    <div id="ending-modal" class="modal" style="border-color: #FFD700;">
        <h2 style="color:#FFD700">ğŸ‰ ì „ì„¤ì˜ ìš©ì‚¬!</h2>
        <p>ì¶•í•˜í•©ë‹ˆë‹¤!<br>ë§ˆì™•ì„ ë¬¼ë¦¬ì¹˜ê³  í‰í™”ë¥¼ ë˜ì°¾ì•˜ìŠµë‹ˆë‹¤!</p>
        <button class="btn-modal" onclick="location.reload()">ë‹¤ì‹œ ëª¨í—˜í•˜ê¸°</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        class Game {
            constructor() {
                // ê²Œì„ ì„¤ì •
                this.config = {
                    gravity: 0.015,
                    bounceForce: 0.35,
                    moveSpeed: 0.12,
                    ballRadius: 0.4
                };
                
                this.resources = { wood: 0, stone: 0, gold: 0 };
                this.questStep = 0; // 0: ì‹œì‘, 1: ì´Œì¥ëŒ€í™”, 2: ê°•í™”í•„ìš”, 3: ë§ˆì™•í† ë²Œ
                
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.ball = null;
                this.ballShadow = null;
                
                this.objects = []; // ë¬¼ë¦¬ ì¶©ëŒì²´
                this.interactables = []; // ìƒí˜¸ì‘ìš© ê°ì²´
                this.particles = [];
                
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.input = { x: 0, z: 0 };
                this.cameraState = { yaw: 0, pitch: 0.5, dist: 14 };
                
                this.isPlaying = true;
                this.activeNPC = null; // í˜„ì¬ ìƒí˜¸ì‘ìš© ê°€ëŠ¥í•œ NPC

                // UI
                this.uiWood = document.getElementById('res-wood');
                this.uiStone = document.getElementById('res-stone');
                this.uiGold = document.getElementById('res-gold');
                this.questBox = document.getElementById('quest-box');
                this.interactBtn = document.getElementById('btn-interact-action');
                
                this.joystickBase = document.getElementById('joystick-base');
                this.joystickKnob = document.getElementById('joystick-knob');
                
                this.init();
            }

            init() {
                // 1. Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 20, 90);

                // 2. Camera
                this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 150);
                
                // 3. Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('game-container').appendChild(this.renderer.domElement);

                // 4. Light
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(30, 50, 30);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                dirLight.shadow.camera.left = -50;
                dirLight.shadow.camera.right = 50;
                dirLight.shadow.camera.top = 50;
                dirLight.shadow.camera.bottom = -50;
                this.scene.add(dirLight);

                // 5. World Generation
                this.createPlayer();
                this.generateMaps();
                this.setupInputs();

                this.showToast("ëª¨í—˜ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!");
                this.animate();
            }

            createPlayer() {
                const geo = new THREE.SphereGeometry(this.config.ballRadius, 32, 32);
                const mat = new THREE.MeshPhongMaterial({ color: 0xFF4500 });
                this.ball = new THREE.Mesh(geo, mat);
                this.ball.position.set(0, 5, 0); // ë§ˆì„ ì‹œì‘
                this.ball.castShadow = true;
                this.scene.add(this.ball);

                const shadowGeo = new THREE.CircleGeometry(this.config.ballRadius, 16);
                const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 });
                this.ballShadow = new THREE.Mesh(shadowGeo, shadowMat);
                this.ballShadow.rotation.x = -Math.PI / 2;
                this.scene.add(this.ballShadow);
            }

            // --- ë§µ ìƒì„± (ìŠ¤í† ë¦¬í˜• 3ë‹¨ êµ¬ì„±) ---
            generateMaps() {
                // Zone 1: í‰í™”ì˜ ë§ˆì„ (ì¤‘ì‹¬: 0, 0)
                this.createIsland(0, 0, 0, 20, 0x7CFC00); 
                this.createHouse(5, 0, 5, 0xFFE4B5); // ì´Œì¥ ì§‘
                this.createNPC(5, 0, 8, 'chief', 'ì´Œì¥');
                this.createNPC(-5, 0, 2, 'shop', 'ìƒì¸');
                this.createTree(8, 0, -5); // ë§ˆì„ ë‚˜ë¬´
                this.createTree(-8, 0, -8);

                // Zone 2: ì£½ìŒì˜ ìˆ² (ë¶ìª½: 0, -50) - ì§•ê²€ë‹¤ë¦¬ë¡œ ì—°ê²°
                this.createBridge(0, 0, -18, 15); 
                this.createIsland(0, 0, -50, 25, 0x228B22); // ì§™ì€ ë…¹ìƒ‰
                
                // ìˆ² ìì› ë°°ì¹˜
                for(let i=0; i<15; i++) {
                    const x = (Math.random()-0.5) * 30;
                    const z = -50 + (Math.random()-0.5) * 30;
                    if(Math.random() > 0.5) this.createTree(x, 0, z);
                    else this.createRock(x, 0, z);
                }

                // Zone 3: ë§ˆì™•ì„± (ë” ë¶ìª½: 0, -110) - ê°€ê¸° í˜ë“¤ê²Œ ë°°ì¹˜
                this.createBridge(0, 2, -73, 10); // ì•½ê°„ ë†’ìŒ
                this.createIsland(0, 5, -110, 15, 0x2F4F4F); // ì–´ë‘ìš´ ìƒ‰
                
                // ë§ˆì™• NPC
                this.createNPC(0, 5, -110, 'boss', 'ë§ˆì™•');
                // ë§ˆì™• ì£¼ë³€ íŒŒí‹°í´
                this.createBossEffect(0, 5, -110);
                
                // ë°”ë‹¤ (ë‚™ì‚¬ êµ¬ì—­)
                const seaGeo = new THREE.PlaneGeometry(500, 500);
                const seaMat = new THREE.MeshPhongMaterial({ color: 0x1E90FF, transparent:true, opacity:0.8 });
                const sea = new THREE.Mesh(seaGeo, seaMat);
                sea.rotation.x = -Math.PI / 2;
                sea.position.y = -5;
                this.scene.add(sea);
            }

            createIsland(x, y, z, radius, color) {
                const geo = new THREE.CylinderGeometry(radius, radius, 10, 32);
                const mat = new THREE.MeshLambertMaterial({ color: color });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y - 5, z); // í‘œë©´ì´ yì— ì˜¤ë„ë¡
                mesh.receiveShadow = true;
                this.scene.add(mesh);
                this.objects.push(mesh);
            }

            createBridge(x, y, z, length) {
                // ì§•ê²€ë‹¤ë¦¬ 3ê°œ
                for(let i=0; i<3; i++) {
                    const bX = x;
                    const bZ = z - (i * (length/3));
                    const bY = y + (i * 0.5); // ì•½ê°„ì”© ë†’ì•„ì§
                    
                    const geo = new THREE.BoxGeometry(3, 1, 3);
                    const mat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(bX, bY - 0.5, bZ);
                    mesh.receiveShadow = true;
                    this.scene.add(mesh);
                    this.objects.push(mesh);
                }
            }

            createHouse(x, y, z, color) {
                const bodyGeo = new THREE.BoxGeometry(4, 3, 4);
                const bodyMat = new THREE.MeshLambertMaterial({ color: color });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.set(x, y+1.5, z);
                body.castShadow = true;
                this.scene.add(body);
                this.objects.push(body);

                const roofGeo = new THREE.ConeGeometry(3.5, 2, 4);
                const roofMat = new THREE.MeshLambertMaterial({ color: 0x8B0000 });
                const roof = new THREE.Mesh(roofGeo, roofMat);
                roof.position.set(x, y+4, z);
                roof.rotation.y = Math.PI/4;
                this.scene.add(roof);
            }

            createNPC(x, y, z, role, name) {
                // ëª¸í†µ
                const geo = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 12);
                let color = 0xCCCCCC;
                if(role === 'shop') color = 0xF1C40F; // ë…¸ë‘
                if(role === 'chief') color = 0x3498DB; // íŒŒë‘
                if(role === 'boss') color = 0xE74C3C; // ë¹¨ê°•
                
                const mat = new THREE.MeshLambertMaterial({ color: color });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y + 0.75, z);
                mesh.castShadow = true;

                // ë¨¸ë¦¬
                const headGeo = new THREE.SphereGeometry(0.4, 12, 12);
                const headMat = new THREE.MeshLambertMaterial({ color: 0xFFE0BD });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 1.0;
                mesh.add(head);

                // ë§ˆì™• ë¿”
                if(role === 'boss') {
                    mesh.scale.set(1.5, 1.5, 1.5);
                    headMat.color.setHex(0x333333);
                }

                mesh.userData = { type: 'npc', role: role, name: name };
                this.scene.add(mesh);
                this.interactables.push(mesh);
                this.objects.push(mesh);
            }

            createTree(x, y, z) {
                const group = new THREE.Group();
                group.position.set(x, y, z);
                group.userData = { type: 'resource', resource: 'wood' };

                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.4, 1.5, 6),
                    new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                );
                trunk.position.y = 0.75;
                trunk.userData = { parent: group };
                group.add(trunk);

                const leaves = new THREE.Mesh(
                    new THREE.ConeGeometry(1.2, 2.5, 8),
                    new THREE.MeshLambertMaterial({ color: 0x228B22 })
                );
                leaves.position.y = 2;
                leaves.userData = { parent: group };
                group.add(leaves);

                this.scene.add(group);
                this.objects.push(trunk);
                this.objects.push(leaves);
            }

            createRock(x, y, z) {
                const mesh = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(0.8, 0),
                    new THREE.MeshLambertMaterial({ color: 0x808080 })
                );
                mesh.position.set(x, y + 0.6, z);
                mesh.scale.set(1.5, 1, 1.5);
                mesh.castShadow = true;
                mesh.userData = { type: 'resource', resource: 'stone', parent: mesh };
                this.scene.add(mesh);
                this.objects.push(mesh);
            }
            
            createBossEffect(x, y, z) {
                for(let i=0; i<20; i++) {
                    const p = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 0.2, 0.2),
                        new THREE.MeshBasicMaterial({ color: 0xFF0000 })
                    );
                    p.position.set(x + (Math.random()-0.5)*5, y + Math.random()*5, z + (Math.random()-0.5)*5);
                    this.scene.add(p);
                }
            }

            // --- ì…ë ¥ ì‹œìŠ¤í…œ ---
            setupInputs() {
                const touchLeft = document.getElementById('touch-left');
                const touchRight = document.getElementById('touch-right');
                
                let joystickId = null;
                let startX = 0, startY = 0;

                // 1. ì¡°ì´ìŠ¤í‹± (ì¢Œì¸¡)
                touchLeft.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if(!this.isPlaying || joystickId !== null) return;
                    const t = e.changedTouches[0];
                    joystickId = t.identifier;
                    startX = t.clientX;
                    startY = t.clientY;
                    this.joystickBase.style.display = 'block';
                    this.joystickBase.style.left = startX + 'px';
                    this.joystickBase.style.top = startY + 'px';
                    this.joystickKnob.style.transform = `translate(-50%, -50%)`;
                    this.input.x = 0; this.input.z = 0;
                }, {passive: false});

                touchLeft.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if(!this.isPlaying) return;
                    for(let i=0; i<e.changedTouches.length; i++) {
                        if(e.changedTouches[i].identifier === joystickId) {
                            const t = e.changedTouches[i];
                            const dx = t.clientX - startX;
                            const dy = t.clientY - startY;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            const maxDist = 40;
                            let moveX = dx, moveY = dy;
                            if(dist > maxDist) {
                                const angle = Math.atan2(dy, dx);
                                moveX = Math.cos(angle) * maxDist;
                                moveY = Math.sin(angle) * maxDist;
                            }
                            this.joystickKnob.style.transform = `translate(calc(-50% + ${moveX}px), calc(-50% + ${moveY}px))`;
                            this.input.x = moveX / maxDist;
                            this.input.z = moveY / maxDist;
                            break;
                        }
                    }
                }, {passive: false});

                const endJoystick = (e) => {
                    e.preventDefault();
                    for(let i=0; i<e.changedTouches.length; i++) {
                        if(e.changedTouches[i].identifier === joystickId) {
                            joystickId = null;
                            this.joystickBase.style.display = 'none';
                            this.input.x = 0; this.input.z = 0;
                            break;
                        }
                    }
                };
                touchLeft.addEventListener('touchend', endJoystick);
                touchLeft.addEventListener('touchcancel', endJoystick);

                // 2. ì¹´ë©”ë¼ (ìš°ì¸¡) - ë²„íŠ¼ í´ë¦­ ì œì™¸
                let lastCamX = 0, lastCamY = 0;
                touchRight.addEventListener('touchstart', (e) => {
                    // ìƒí˜¸ì‘ìš© ë²„íŠ¼ ìœ„ë©´ ë¬´ì‹œ
                    if(e.target.id === 'btn-interact-action') return;
                    e.preventDefault();
                    if(!this.isPlaying) return;
                    lastCamX = e.changedTouches[0].clientX;
                    lastCamY = e.changedTouches[0].clientY;
                }, {passive: false});

                touchRight.addEventListener('touchmove', (e) => {
                    if(e.target.id === 'btn-interact-action') return;
                    e.preventDefault();
                    if(!this.isPlaying) return;
                    const t = e.changedTouches[0];
                    const dx = t.clientX - lastCamX;
                    const dy = t.clientY - lastCamY;
                    this.rotateCamera(dx * 2, dy * 2);
                    lastCamX = t.clientX;
                    lastCamY = t.clientY;
                }, {passive: false});

                // 3. ìƒí˜¸ì‘ìš© ë²„íŠ¼
                this.interactBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // ì´ë²¤íŠ¸ ì „íŒŒ ë°©ì§€
                    this.interact();
                });
                
                // ëª¨ë°”ì¼ í„°ì¹˜ ëŒ€ì‘
                this.interactBtn.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    this.interact();
                });

                // 4. PC Controls
                document.addEventListener('keydown', (e) => {
                    if(!this.isPlaying) return;
                    switch(e.key.toLowerCase()) {
                        case 'w': this.input.z = -1; break;
                        case 's': this.input.z = 1; break;
                        case 'a': this.input.x = -1; break;
                        case 'd': this.input.x = 1; break;
                        case 'e': this.interact(); break;
                    }
                });
                document.addEventListener('keyup', (e) => {
                    switch(e.key.toLowerCase()) {
                        case 'w': case 's': this.input.z = 0; break;
                        case 'a': case 'd': this.input.x = 0; break;
                    }
                });
                
                // PC ë§ˆìš°ìŠ¤ ë“œë˜ê·¸
                let isMouseDown = false;
                document.addEventListener('mousedown', (e) => {
                   if(!this.isPlaying || e.target.tagName === 'BUTTON' || e.target.id === 'btn-interact-action') return;
                   if(!('ontouchstart' in window)) {
                       isMouseDown = true;
                       lastCamX = e.clientX;
                       lastCamY = e.clientY;
                   }
                });
                document.addEventListener('mousemove', (e) => {
                    if(isMouseDown) {
                        this.rotateCamera(e.clientX - lastCamX, e.clientY - lastCamY);
                        lastCamX = e.clientX;
                        lastCamY = e.clientY;
                    }
                });
                document.addEventListener('mouseup', () => isMouseDown = false);
            }

            rotateCamera(dx, dy) {
                const sensitivity = 0.003;
                this.cameraState.yaw -= dx * sensitivity;
                this.cameraState.pitch = Math.max(0.1, Math.min(Math.PI/2 - 0.1, this.cameraState.pitch + dy * sensitivity));
            }

            // --- ê²Œì„ ë¡œì§ ---
            updatePhysics() {
                // ì¤‘ë ¥
                this.velocity.y -= this.config.gravity;
                this.ball.position.add(this.velocity);

                // ì´ë™ (ì¹´ë©”ë¼ ë°©í–¥ ê¸°ì¤€)
                const camAngle = this.cameraState.yaw;
                const targetVX = (this.input.x * Math.cos(camAngle) + this.input.z * Math.sin(camAngle)) * this.config.moveSpeed;
                const targetVZ = (this.input.x * -Math.sin(camAngle) + this.input.z * Math.cos(camAngle)) * this.config.moveSpeed;
                this.velocity.x += (targetVX - this.velocity.x) * 0.1;
                this.velocity.z += (targetVZ - this.velocity.z) * 0.1;

                // ì¶©ëŒ
                const raycaster = new THREE.Raycaster();
                raycaster.set(this.ball.position, new THREE.Vector3(0, -1, 0));
                const intersects = raycaster.intersectObjects(this.objects);
                
                let shadowY = -100;
                if (intersects.length > 0) {
                    const hit = intersects[0];
                    shadowY = hit.point.y + 0.05;

                    if (hit.distance < this.config.ballRadius && this.velocity.y < 0) {
                        this.velocity.y = this.config.bounceForce;
                        this.ball.position.y = hit.point.y + this.config.ballRadius;
                        
                        // ìŠ¤ì¿¼ì‹œ íš¨ê³¼
                        this.ball.scale.set(1.3, 0.7, 1.3);
                        setTimeout(() => this.ball.scale.set(1, 1, 1), 100);

                        // ìì› ì±„ì§‘
                        let target = hit.object;
                        if (!target.userData.type && target.userData.parent) target = target.userData.parent;
                        if (target.userData.type === 'resource') this.gatherResource(target);
                    }
                }
                
                this.ballShadow.position.set(this.ball.position.x, shadowY, this.ball.position.z);
                this.ballShadow.visible = shadowY > -10;

                // ë‚™ì‚¬
                if (this.ball.position.y < -10) {
                    this.ball.position.set(0, 10, 0);
                    this.velocity.set(0, 0, 0);
                    this.showToast("ë¬¼ì— ë¹ ì ¸ ë§ˆì„ë¡œ ëŒì•„ì™”ìŠµë‹ˆë‹¤.");
                }

                // NPC ì²´í¬
                this.checkNPCs();

                // ê³µ íšŒì „
                this.ball.rotation.x -= this.velocity.z * 1.5;
                this.ball.rotation.z += this.velocity.x * 1.5;
            }

            gatherResource(obj) {
                const type = obj.userData.resource;
                // ìì› ì¦ê°€
                if (type === 'wood') this.resources.wood++;
                if (type === 'stone') this.resources.stone++;
                
                // UI ì—…ë°ì´íŠ¸
                this.updateUI();
                this.showToast(`${type === 'wood' ? 'ë‚˜ë¬´' : 'ëŒ'} íšë“!`);

                // ì œê±° ë° ë¦¬ì  
                this.scene.remove(obj);
                
                // ì¶©ëŒì²´ ëª©ë¡ì—ì„œ ì œê±° (ì„ì‹œ)
                let tempRemoved = [];
                obj.traverse((child) => { if(this.objects.includes(child)) tempRemoved.push(child); });
                if(this.objects.includes(obj)) tempRemoved.push(obj);
                this.objects = this.objects.filter(o => !tempRemoved.includes(o));

                setTimeout(() => {
                    this.scene.add(obj);
                    tempRemoved.forEach(o => this.objects.push(o));
                }, 5000);
            }

            checkNPCs() {
                let closest = null;
                let minDist = 4; // ëŒ€í™” ê°€ëŠ¥ ê±°ë¦¬

                for(let obj of this.interactables) {
                    if(obj.userData.type === 'npc') {
                        const dist = this.ball.position.distanceTo(obj.position);
                        if(dist < minDist) {
                            minDist = dist;
                            closest = obj;
                        }
                    }
                }

                if(closest !== this.activeNPC) {
                    this.activeNPC = closest;
                    if(closest) {
                        this.interactBtn.classList.add('active');
                        this.showToast(`[${closest.userData.name}] ëŒ€í™” ê°€ëŠ¥`);
                    } else {
                        this.interactBtn.classList.remove('active');
                    }
                }
            }

            interact() {
                if(!this.activeNPC) return;
                const role = this.activeNPC.userData.role;

                if(role === 'shop') {
                    document.getElementById('shop-modal').style.display = 'block';
                    this.isPlaying = false;
                } else if(role === 'chief') {
                    const modal = document.getElementById('dialogue-modal');
                    const title = document.getElementById('npc-name');
                    const text = document.getElementById('npc-text');
                    
                    title.innerText = "ì´Œì¥";
                    modal.style.display = 'block';
                    this.isPlaying = false;

                    if(this.questStep === 0) {
                        text.innerText = "ìë„¤ê°€ ì „ì„¤ì˜ ìš©ì‚¬ì¸ê°€? ë¶ìª½ ìˆ² ë„ˆë¨¸ ë§ˆì™•ì´ ë‚˜íƒ€ë‚¬ë„¤! í•˜ì§€ë§Œ ì§€ê¸ˆ ì‹¤ë ¥ìœ¼ë¡  ì–´ë¦¼ì—†ì§€. ìì›ì„ ëª¨ì•„ 'ìƒì¸'ì—ê²Œ ê°€ì„œ í˜ì„ ê¸°ë¥´ê²Œ!";
                        this.questBox.innerText = "ğŸ“œ ëª©í‘œ: ìì›ì„ ëª¨ì•„ ì í”„ë ¥ ê°•í™”í•˜ê¸°";
                        this.questStep = 1;
                    } else if(this.questStep === 1) {
                        text.innerText = "ì•„ì§ ì¤€ë¹„ê°€ ì•ˆ ëêµ°. ë‚˜ë¬´ì™€ ëŒì„ ëª¨ì•„ ìƒì¸ì—ê²Œ íŒŒì‹œê²Œ. ê·¸ë¦¬ê³  ì í”„ë ¥ì„ ê°•í™”í•´ì„œ ì˜¤ê²Œë‚˜.";
                    } else if(this.questStep === 2) {
                        text.innerText = "ì˜¤! í˜ì´ ëŠê»´ì§€ëŠ”êµ°. ì´ì œ ë¶ìª½ ìˆ² ì§•ê²€ë‹¤ë¦¬ë¥¼ ê±´ë„ˆ ë§ˆì™•ì„±ì— ê°ˆ ìˆ˜ ìˆì„ ê±¸ì„¸. ë¶€ë”” ì¡°ì‹¬í•˜ê²Œ!";
                        this.questBox.innerText = "ğŸ“œ ëª©í‘œ: ë¶ìª½ ë§ˆì™•ì„±ìœ¼ë¡œ ê°€ì„œ ë§ˆì™• ë¬´ì°Œë¥´ê¸°";
                        this.questStep = 3;
                    } else {
                        text.innerText = "ë§ˆì™•ì„ ë¬¼ë¦¬ì³ ì£¼ê²Œ!";
                    }
                } else if(role === 'boss') {
                    document.getElementById('ending-modal').style.display = 'block';
                    this.isPlaying = false;
                }
            }

            sellResources() {
                if(this.resources.wood >= 5 && this.resources.stone >= 5) {
                    this.resources.wood -= 5;
                    this.resources.stone -= 5;
                    this.resources.gold += 30;
                    this.updateUI();
                    this.showToast("ìì›ì„ íŒ”ì•„ 30ê³¨ë“œë¥¼ ì–»ì—ˆìŠµë‹ˆë‹¤.");
                } else {
                    this.showToast("ë‚˜ë¬´ì™€ ëŒì´ 5ê°œì”© í•„ìš”í•©ë‹ˆë‹¤.");
                }
            }

            upgradeJump() {
                if(this.resources.gold >= 100) {
                    this.resources.gold -= 100;
                    this.config.bounceForce += 0.15; // ëŒ€í­ ìƒìŠ¹
                    this.updateUI();
                    this.showToast("ì í”„ë ¥ì´ ëŒ€í­ ê°•í™”ë˜ì—ˆìŠµë‹ˆë‹¤! ì´ì œ ë§ˆì™•ì„±ì— ê°ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
                    if(this.questStep === 1) this.questStep = 2; // í€˜ìŠ¤íŠ¸ ì§„í–‰
                    this.questBox.innerText = "ğŸ“œ ëª©í‘œ: ì´Œì¥ë‹˜ê»˜ ë‹¤ì‹œ ê°€ë³´ì„¸ìš”.";
                } else {
                    this.showToast("100ê³¨ë“œê°€ í•„ìš”í•©ë‹ˆë‹¤.");
                }
            }

            closeShop() {
                document.getElementById('shop-modal').style.display = 'none';
                this.isPlaying = true;
                this.input.x = 0; this.input.z = 0;
            }

            closeDialogue() {
                document.getElementById('dialogue-modal').style.display = 'none';
                this.isPlaying = true;
            }

            updateUI() {
                this.uiWood.innerText = this.resources.wood;
                this.uiStone.innerText = this.resources.stone;
                this.uiGold.innerText = this.resources.gold;
            }

            showToast(msg) {
                const toast = document.getElementById('toast');
                toast.innerText = msg;
                toast.style.opacity = 1;
                setTimeout(() => { toast.style.opacity = 0; }, 2000);
            }

            updateCamera() {
                const cx = this.ball.position.x + this.cameraState.dist * Math.cos(this.cameraState.pitch) * Math.sin(this.cameraState.yaw);
                const cz = this.ball.position.z + this.cameraState.dist * Math.cos(this.cameraState.pitch) * Math.cos(this.cameraState.yaw);
                const cy = this.ball.position.y + this.cameraState.dist * Math.sin(this.cameraState.pitch);
                this.camera.position.lerp(new THREE.Vector3(cx, cy, cz), 0.1);
                this.camera.lookAt(this.ball.position);
            }

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                if (this.isPlaying) this.updatePhysics();
                if (this.ball) this.updateCamera();
                this.renderer.render(this.scene, this.camera);
            }
        }

        const game = new Game();
    </script>
</body>
</html>
