<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Bounce Ball RPG: Final Cut</title>
    <link href="https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Do+Hyeon&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1e1e1e;
            font-family: 'Noto Sans KR', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container { width: 100vw; height: 100vh; display: block; }

        /* UI ë ˆì´ì–´ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10; transition: opacity 0.5s;
        }
        body.cinematic #ui-layer { opacity: 0; }

        /* ë ˆí„°ë°•ìŠ¤ */
        .letterbox {
            position: absolute; left: 0; width: 100%; height: 0;
            background: black; z-index: 20; transition: height 0.5s ease;
        }
        .letterbox.top { top: 0; }
        .letterbox.bottom { bottom: 0; }
        body.cinematic .letterbox { height: 12%; }

        /* HUD */
        .hud-panel {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px; border-radius: 15px;
            border: 2px solid #fff;
            color: #fff; font-family: 'Do Hyeon', sans-serif; font-size: 18px;
            display: flex; gap: 15px;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        /* í€˜ìŠ¤íŠ¸ */
        .quest-panel {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px; border-radius: 10px;
            border-left: 5px solid #f39c12;
            color: #fff; font-size: 14px; width: 220px;
            text-shadow: 1px 1px 0 #000;
        }
        .quest-title { color: #f39c12; font-weight: bold; margin-bottom: 5px; font-size: 16px; }

        /* ì¡°ì´ìŠ¤í‹± */
        #joystick-zone {
            position: absolute; bottom: 40px; left: 40px;
            width: 140px; height: 140px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: auto; display: none;
        }
        #joystick-knob {
            position: absolute; top: 50%; left: 50%;
            width: 60px; height: 60px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        /* ìƒí˜¸ì‘ìš© ë²„íŠ¼ */
        #btn-interact {
            position: absolute; bottom: 50px; right: 50px;
            width: 80px; height: 80px;
            background: radial-gradient(circle, #f1c40f, #f39c12);
            border: 3px solid #fff; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.6);
            transform: scale(0); transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            pointer-events: auto; cursor: pointer; z-index: 50;
        }
        #btn-interact.visible { transform: scale(1); }
        #btn-interact::after { content: 'TALK'; font-weight: bold; color: #fff; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
        #btn-interact.shop::after { content: 'SHOP'; }

        /* ëŒ€í™”ì°½ */
        #dialogue-box {
            position: absolute; bottom: -250px; left: 50%; transform: translateX(-50%);
            width: 80%; max-width: 800px; height: 160px;
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid #fff; border-radius: 15px;
            padding: 25px; box-sizing: border-box;
            color: #fff; z-index: 30;
            transition: bottom 0.5s ease;
            display: flex; flex-direction: column;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            pointer-events: auto; cursor: pointer;
        }
        body.cinematic #dialogue-box { bottom: 60px; }
        .npc-name { color: #f1c40f; font-weight: bold; font-size: 22px; margin-bottom: 10px; }
        .dialogue-text { font-size: 19px; line-height: 1.6; }
        .dialogue-next { align-self: flex-end; color: #aaa; font-size: 14px; margin-top: auto; animation: blink 1s infinite; }

        /* ìƒì  ëª¨ë‹¬ */
        .modal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); display: none; z-index: 100;
            justify-content: center; align-items: center; pointer-events: auto;
            backdrop-filter: blur(5px);
        }
        .shop-content {
            background: #fff; width: 400px; border-radius: 15px; padding: 25px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5); font-family: 'Do Hyeon', sans-serif;
            text-align: center; border: 4px solid #333;
        }
        .shop-item {
            background: #f9f9f9; margin: 12px 0; padding: 15px; border-radius: 10px;
            display: flex; justify-content: space-between; align-items: center;
            border: 1px solid #ddd;
        }
        .shop-btn {
            background: #27ae60; color: white; border: none; padding: 8px 16px;
            border-radius: 6px; cursor: pointer; font-family: inherit; font-size: 16px;
        }
        .shop-btn:hover { background: #219150; }

        /* í† ìŠ¤íŠ¸ */
        #toast {
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: #f1c40f; padding: 12px 30px;
            border-radius: 30px; font-weight: bold; opacity: 0; transition: opacity 0.5s;
            pointer-events: none; font-size: 20px; z-index: 60;
        }

        @keyframes blink { 50% { opacity: 0; } }

        #touch-camera { position: absolute; top: 0; right: 0; width: 50%; height: 100%; pointer-events: auto; }
        #touch-move { position: absolute; top: 0; left: 0; width: 50%; height: 100%; pointer-events: auto; }
    </style>
</head>
<body>

    <div id="game-container"></div>

    <div class="letterbox top"></div>
    <div class="letterbox bottom"></div>

    <div id="ui-layer">
        <div class="hud-panel">
            <span>ğŸªµ <span id="res-wood">0</span></span>
            <span>ğŸª¨ <span id="res-stone">0</span></span>
            <span>ğŸ’ <span id="res-gem">0</span></span>
            <span style="color:#f1c40f">ğŸ’° <span id="res-gold">0</span></span>
        </div>

        <div class="quest-panel">
            <div class="quest-title">ğŸ“œ QUEST</div>
            <div id="quest-desc">ì´Œì¥ë‹˜ê³¼ ëŒ€í™”í•˜ì—¬ ëª¨í—˜ì„ ì‹œì‘í•˜ì„¸ìš”.</div>
        </div>

        <div id="joystick-zone"><div id="joystick-knob"></div></div>
        <div id="btn-interact"></div>
        <div id="toast">ì•Œë¦¼</div>

        <div id="touch-move"></div>
        <div id="touch-camera"></div>
    </div>

    <div id="dialogue-box">
        <div class="npc-name" id="dial-name">Name</div>
        <div class="dialogue-text" id="dial-text">...</div>
        <div class="dialogue-next">í„°ì¹˜í•˜ì—¬ ê³„ì† â–¶</div>
    </div>

    <div id="shop-modal" class="modal-overlay">
        <div class="shop-content">
            <h2 style="margin-top:0; color:#e67e22;">ğŸ›’ ëª¨í—˜ê°€ ìƒì </h2>
            <div class="shop-item">
                <div style="text-align:left">
                    <strong>ìì› íŒë§¤</strong><br>
                    <small>ë‚˜ë¬´/ëŒ/ë³´ì„ 5ê°œ â†’ 50G</small>
                </div>
                <button class="shop-btn" onclick="game.shopSell()">íŒë§¤</button>
            </div>
            <div class="shop-item">
                <div style="text-align:left">
                    <strong>ì í”„ë ¥ ê°•í™”</strong> (200G)<br>
                    <small>ë†’ì€ ê³³ì— ê°ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</small>
                </div>
                <button class="shop-btn" onclick="game.shopUpgradeJump()">ê°•í™”</button>
            </div>
            <div class="shop-item">
                <div style="text-align:left">
                    <strong>ì´ë™ì†ë„ ê°•í™”</strong> (100G)<br>
                    <small>íŒŒì¿ ë¥´ê°€ ì‰¬ì›Œì§‘ë‹ˆë‹¤.</small>
                </div>
                <button class="shop-btn" onclick="game.shopUpgradeSpeed()">ê°•í™”</button>
            </div>
            <button class="shop-btn" style="background:#7f8c8d; width:100%; margin-top:10px;" onclick="game.closeShop()">ë‚˜ê°€ê¸°</button>
        </div>
    </div>

    <div id="ending-screen" class="modal-overlay" style="background:black;">
        <div style="color:white; text-align:center;">
            <h1 style="color:#f1c40f; font-size:60px; margin-bottom:20px;">THE END</h1>
            <p style="font-size:24px;">ì „ì„¤ì˜ ìš©ì‚¬ì—¬, ë§ˆì™•ì„ ë¬¼ë¦¬ì¹˜ê³  ì„¸ê³„ë¥¼ êµ¬í–ˆìŠµë‹ˆë‹¤!</p>
            <br><br>
            <button class="shop-btn" style="padding:15px 40px; font-size:20px;" onclick="location.reload()">ì²˜ìŒë¶€í„° ë‹¤ì‹œ í•˜ê¸°</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        class Game {
            constructor() {
                this.config = {
                    gravity: 0.018,
                    bounceForce: 0.40,
                    moveSpeed: 0.14,
                    ballRadius: 0.45
                };
                
                this.stats = { jumpLevel: 1, speedLevel: 1 };
                this.resources = { wood: 0, stone: 0, gem: 0, gold: 0 };
                this.questState = 0; 
                
                this.scene = null; this.camera = null; this.renderer = null;
                this.ball = null; this.ballShadow = null;
                
                this.colliders = [];
                this.interactables = [];
                this.movingPlatforms = [];
                this.textures = {}; 
                
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.input = { x: 0, z: 0 };
                this.cameraState = { yaw: 0, pitch: 0.5, dist: 14 };
                
                this.activeNPC = null;
                this.inCutscene = false;
                this.dialogueTimer = null; // ëŒ€í™” íƒ€ì´ë¨¸ ì „ì—­ ê´€ë¦¬

                this.els = {
                    wood: document.getElementById('res-wood'),
                    stone: document.getElementById('res-stone'),
                    gem: document.getElementById('res-gem'),
                    gold: document.getElementById('res-gold'),
                    quest: document.getElementById('quest-desc'),
                    toast: document.getElementById('toast'),
                    interactBtn: document.getElementById('btn-interact'),
                    dialogueBox: document.getElementById('dialogue-box'),
                    dialName: document.getElementById('dial-name'),
                    dialText: document.getElementById('dial-text'),
                    joystickZone: document.getElementById('joystick-zone'),
                    joystickKnob: document.getElementById('joystick-knob')
                };

                this.init();
            }

            init() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 20, 150);

                this.camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 500);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('game-container').appendChild(this.renderer.domElement);

                const ambient = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambient);
                const sun = new THREE.DirectionalLight(0xffffff, 0.8);
                sun.position.set(50, 100, 50);
                sun.castShadow = true;
                sun.shadow.mapSize.width = 4096;
                sun.shadow.mapSize.height = 4096;
                sun.shadow.camera.left = -100; sun.shadow.camera.right = 100;
                sun.shadow.camera.top = 100; sun.shadow.camera.bottom = -100;
                this.scene.add(sun);

                this.generateTextures();
                this.createPlayer();
                this.buildLevel();
                this.setupInputs();

                this.startCutscene([
                    { name: "ë‚´ë ˆì´ì…˜", text: "í‰í™”ë¡­ë˜ ë°”ìš´ìŠ¤ ì›”ë“œì— ì–´ë‘ ì´ ì°¾ì•„ì™”ìŠµë‹ˆë‹¤." },
                    { name: "ë‚´ë ˆì´ì…˜", text: "ë§ˆì™•ì´ ë¶ìª½ í•˜ëŠ˜ì„¬ì„ ì ë ¹í•˜ê³  ì„¸ê³„ë¥¼ ìœ„í˜‘í•˜ê³  ìˆìŠµë‹ˆë‹¤." },
                    { name: "ì‹œìŠ¤í…œ", text: "ë§ˆì„ ì´Œì¥ë‹˜ì„ ë§Œë‚˜ ëª¨í—˜ì„ ì‹œì‘í•˜ì„¸ìš”." }
                ]);

                this.animate();
                window.addEventListener('resize', () => this.onResize());
            }

            generateTextures() {
                this.textures.grass = this.createTexture('#4CAF50', '#388E3C', 'noise');
                this.textures.stone = this.createTexture('#9E9E9E', '#757575', 'noise');
                this.textures.wood = this.createTexture('#8D6E63', '#5D4037', 'lines');
                this.textures.dirt = this.createTexture('#795548', '#5D4037', 'noise');
                this.textures.lava = this.createTexture('#F44336', '#B71C1C', 'noise');
            }

            createTexture(color1, color2, type) {
                const canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 256;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = color1; ctx.fillRect(0, 0, 256, 256);
                
                if (type === 'noise') {
                    for(let i=0; i<3000; i++) {
                        ctx.fillStyle = color2;
                        const x = Math.random() * 256; const y = Math.random() * 256;
                        const s = Math.random() * 4; ctx.fillRect(x, y, s, s);
                    }
                } else if (type === 'lines') {
                    ctx.strokeStyle = color2; ctx.lineWidth = 2;
                    for(let i=0; i<20; i++) {
                        ctx.beginPath();
                        const y = Math.random() * 256;
                        ctx.moveTo(0, y); ctx.lineTo(256, y + (Math.random()-0.5)*20);
                        ctx.stroke();
                    }
                }
                const tex = new THREE.CanvasTexture(canvas);
                tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
                return tex;
            }

            createPlayer() {
                const geo = new THREE.SphereGeometry(this.config.ballRadius, 32, 32);
                const mat = new THREE.MeshPhongMaterial({ color: 0xe74c3c, shininess: 80 });
                this.ball = new THREE.Mesh(geo, mat);
                this.ball.position.set(0, 2, 0);
                this.ball.castShadow = true;
                this.scene.add(this.ball);

                const sGeo = new THREE.CircleGeometry(this.config.ballRadius, 16);
                const sMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 });
                this.ballShadow = new THREE.Mesh(sGeo, sMat);
                this.ballShadow.rotation.x = -Math.PI/2;
                this.scene.add(this.ballShadow);
            }

            buildLevel() {
                this.createPlatform(0, 0, 0, 30, 30, 'grass', 'cylinder');
                this.createHouse(8, 0, 5, 0xf1c40f);
                this.createHouse(-8, 0, 8, 0xe67e22);
                this.createNPC(5, 0, 5, 'chief', 'ì´Œì¥', 0x3498db);
                this.createNPC(-5, 0, 8, 'shop', 'ìƒì¸', 0x9b59b6);
                this.scatterResources(0, 0, 0, 13, 'wood', 6);
                this.scatterResources(0, 0, 0, 13, 'stone', 4);

                this.createBridge(0, 0.05, -18, 5);
                this.createPlatform(0, 0, -50, 20, 20, 'grass', 'cylinder');
                this.createPlatform(10, 3, -50, 6, 6, 'dirt');
                this.createPlatform(0, 6, -60, 6, 6, 'dirt');
                this.createPlatform(-10, 9, -50, 6, 6, 'dirt');
                this.createPlatform(0, 12, -40, 6, 6, 'dirt');
                
                this.createResource(10, 3, -50, 'wood');
                this.createResource(-10, 9, -50, 'gem');

                this.createMovingPlatform(0, 12, -25, 4, 0, 0, 10, 'z');
                this.createMovingPlatform(0, 12, -5, 3, 0, 0, 8, 'x');
                
                this.createPlatform(0, 15, 10, 3, 3, 'stone');
                this.createBridge(0, 15.05, 20, 3);
                this.createPlatform(0, 15, 45, 25, 25, 'stone', 'cylinder');
                this.createNPC(0, 15, 45, 'boss', 'ë§ˆì™•', 0xe74c3c);
                this.createLava(0, 15, 45);

                const sea = new THREE.Mesh(
                    new THREE.PlaneGeometry(500, 500),
                    new THREE.MeshBasicMaterial({ color: 0x1E90FF, transparent:true, opacity:0.6 })
                );
                sea.rotation.x = -Math.PI/2; sea.position.y = -20;
                this.scene.add(sea);
            }

            createPlatform(x, y, z, w, d, texName, shape='box') {
                const tex = this.textures[texName] || this.textures.grass;
                const mat = new THREE.MeshLambertMaterial({ map: tex });
                let mesh;
                if(shape === 'cylinder') {
                    mesh = new THREE.Mesh(new THREE.CylinderGeometry(w, w, 10, 32), mat);
                    mesh.position.set(x, y - 5, z);
                } else {
                    mesh = new THREE.Mesh(new THREE.BoxGeometry(w, 1, d), mat);
                    mesh.position.set(x, y - 0.5, z);
                }
                mesh.receiveShadow = true;
                this.scene.add(mesh);
                const box = new THREE.Box3().setFromObject(mesh);
                mesh.userData = { box, type: 'ground' };
                this.colliders.push(mesh);
                return mesh;
            }

            createBridge(x, y, z, count) {
                const tex = this.textures.wood;
                const mat = new THREE.MeshLambertMaterial({ map: tex });
                for(let i=0; i<count; i++) {
                    const mesh = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 3), mat);
                    mesh.position.set(x, y, z - (i * 3.5));
                    mesh.receiveShadow = true;
                    this.scene.add(mesh);
                    const box = new THREE.Box3().setFromObject(mesh);
                    mesh.userData = { box, type: 'ground' };
                    this.colliders.push(mesh);
                }
            }

            createMovingPlatform(x, y, z, size, ox, oy, oz, axis) {
                const mesh = this.createPlatform(x, y, z, size, size, 'stone');
                mesh.material = new THREE.MeshLambertMaterial({ color: 0x3498db });
                mesh.userData.isMoving = true;
                mesh.userData.origin = { x, y: y-0.5, z };
                mesh.userData.axis = axis;
                mesh.userData.speed = 0.002 + Math.random()*0.001;
                mesh.userData.range = 8;
                this.movingPlatforms.push(mesh);
            }

            createHouse(x, y, z, color) {
                const base = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 4), new THREE.MeshLambertMaterial({color}));
                base.position.set(x, y+1.5, z);
                base.castShadow = true;
                this.scene.add(base);
                const box = new THREE.Box3().setFromObject(base);
                base.userData = { box, type: 'ground' };
                this.colliders.push(base);
                const roof = new THREE.Mesh(new THREE.ConeGeometry(3.5, 2, 4), new THREE.MeshLambertMaterial({color:0xc0392b}));
                roof.position.set(x, y+4, z); roof.rotation.y = Math.PI/4;
                this.scene.add(roof);
            }

            createNPC(x, y, z, id, name, color) {
                const group = new THREE.Group();
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.5, 12), new THREE.MeshLambertMaterial({color}));
                body.position.y = 0.75;
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshLambertMaterial({color:0xffe0bd}));
                head.position.y = 1.6;
                group.add(body); group.add(head);
                if(id === 'boss') { group.scale.set(2, 2, 2); head.material.color.setHex(0x333333); }
                group.position.set(x, y, z); group.castShadow = true;
                this.scene.add(group);
                group.userData = { type: 'npc', id, name };
                this.interactables.push(group);
                const box = new THREE.Box3().setFromObject(group);
                group.userData.box = box;
                this.colliders.push(group);
            }

            createResource(x, y, z, type) {
                let mesh;
                if(type === 'wood') {
                    const g = new THREE.Group();
                    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 1, 8), new THREE.MeshLambertMaterial({map: this.textures.wood}));
                    trunk.position.y = 0.5;
                    const leaf = new THREE.Mesh(new THREE.ConeGeometry(1, 2, 8), new THREE.MeshLambertMaterial({color:0x228B22}));
                    leaf.position.y = 1.5;
                    g.add(trunk); g.add(leaf); g.position.set(x, y, z); mesh = g;
                } else if(type === 'stone') {
                    mesh = new THREE.Mesh(new THREE.DodecahedronGeometry(0.6), new THREE.MeshLambertMaterial({map: this.textures.stone}));
                    mesh.position.set(x, y+0.5, z);
                } else if(type === 'gem') {
                    mesh = new THREE.Mesh(new THREE.OctahedronGeometry(0.5), new THREE.MeshPhongMaterial({color:0x9b59b6, emissive:0x8e44ad}));
                    mesh.position.set(x, y+0.8, z);
                }
                mesh.castShadow = true; this.scene.add(mesh);
                const box = new THREE.Box3().setFromObject(mesh);
                mesh.userData = { type: 'resource', resType: type, box };
                this.colliders.push(mesh);
            }

            scatterResources(cx, cy, cz, radius, type, count) {
                for(let i=0; i<count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.random() * (radius - 3);
                    this.createResource(cx + Math.cos(angle)*r, cy, cz + Math.sin(angle)*r, type);
                }
            }

            createLava(x, y, z) {
                const geo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
                const mat = new THREE.MeshBasicMaterial({color:0xff3300});
                for(let i=0; i<15; i++) {
                    const m = new THREE.Mesh(geo, mat);
                    m.position.set(x + (Math.random()-0.5)*20, y, z + (Math.random()-0.5)*20);
                    this.scene.add(m);
                }
            }

            updatePhysics() {
                const time = Date.now();
                this.movingPlatforms.forEach(p => {
                    const val = p.userData.origin[p.userData.axis] + Math.sin(time * p.userData.speed) * p.userData.range;
                    if(p.userData.axis === 'x') p.position.x = val;
                    else if(p.userData.axis === 'z') p.position.z = val;
                    p.userData.box.setFromObject(p);
                });

                this.velocity.y -= this.config.gravity;
                this.ball.position.add(this.velocity);

                const cy = this.cameraState.yaw;
                const tx = (this.input.x * Math.cos(cy) + this.input.z * Math.sin(cy)) * this.config.moveSpeed * this.stats.speedLevel;
                const tz = (this.input.x * -Math.sin(cy) + this.input.z * Math.cos(cy)) * this.config.moveSpeed * this.stats.speedLevel;
                this.velocity.x += (tx - this.velocity.x) * 0.15;
                this.velocity.z += (tz - this.velocity.z) * 0.15;

                const r = this.config.ballRadius * 0.7; 
                const offsets = [
                    new THREE.Vector3(0,0,0), new THREE.Vector3(r,0,0), new THREE.Vector3(-r,0,0),
                    new THREE.Vector3(0,0,r), new THREE.Vector3(0,0,-r)
                ];
                const raycaster = new THREE.Raycaster();
                raycaster.far = this.config.ballRadius + 0.3;
                const down = new THREE.Vector3(0, -1, 0);

                let groundY = -999;
                let hitObj = null;

                for(let off of offsets) {
                    const origin = this.ball.position.clone().add(off);
                    raycaster.set(origin, down);
                    const intersects = raycaster.intersectObjects(this.colliders);
                    if(intersects.length > 0) {
                        const hit = intersects[0];
                        if(hit.point.y > groundY) {
                            groundY = hit.point.y;
                            hitObj = hit.object;
                        }
                    }
                }

                if (this.velocity.y < 0 && this.ball.position.y <= groundY + this.config.ballRadius + 0.15) {
                    this.velocity.y = this.config.bounceForce + (this.stats.jumpLevel * 0.05);
                    this.ball.position.y = groundY + this.config.ballRadius;
                    
                    let target = hitObj;
                    while(target && !target.userData.type) target = target.parent;
                    if(target && target.userData.type === 'resource') {
                        this.gatherResource(target);
                    }
                }

                if(groundY > -100) {
                    this.ballShadow.position.set(this.ball.position.x, groundY + 0.02, this.ball.position.z);
                    this.ballShadow.visible = true;
                } else {
                    this.ballShadow.visible = false;
                }

                if(this.ball.position.y < -30) {
                    this.ball.position.set(0, 5, 0);
                    this.velocity.set(0,0,0);
                    this.showToast("êµ¬ì¡°ë˜ì—ˆìŠµë‹ˆë‹¤!");
                }

                this.ball.rotation.x -= this.velocity.z * 1.5;
                this.ball.rotation.z += this.velocity.x * 1.5;
                this.checkInteractions();
            }

            checkInteractions() {
                let closest = null;
                let minDist = 6; 
                this.interactables.forEach(npc => {
                    const dx = this.ball.position.x - npc.position.x;
                    const dz = this.ball.position.z - npc.position.z;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    if(dist < minDist) {
                        minDist = dist;
                        closest = npc;
                    }
                });

                if(closest !== this.activeNPC) {
                    this.activeNPC = closest;
                    const btn = this.els.interactBtn;
                    if(closest) {
                        btn.classList.add('visible');
                        btn.className = closest.userData.id === 'shop' ? 'shop' : '';
                        btn.classList.add('visible');
                        this.showToast(`[${closest.userData.name}]`);
                    } else {
                        btn.classList.remove('visible');
                    }
                }
            }

            interact() {
                if(this.inCutscene || !this.activeNPC) return;
                const id = this.activeNPC.userData.id;
                
                if(id === 'shop') {
                    document.getElementById('shop-modal').style.display = 'flex';
                    this.inCutscene = true;
                } else if(id === 'chief') {
                    this.runQuestLogic();
                } else if(id === 'boss') {
                    document.getElementById('ending-screen').style.display = 'flex';
                    this.inCutscene = true;
                }
            }

            startCutscene(lines) {
                // ê¸°ì¡´ íƒ€ì´ë¨¸ í´ë¦¬ì–´
                if(this.dialogueTimer) clearTimeout(this.dialogueTimer);
                
                this.inCutscene = true;
                document.body.classList.add('cinematic');
                this.input.x = 0; this.input.z = 0;
                this.startDialogue(lines, () => {
                    document.body.classList.remove('cinematic');
                    this.inCutscene = false;
                });
            }

            startDialogue(lines, onComplete) {
                const box = this.els.dialogueBox;
                const nameEl = this.els.dialName;
                const textEl = this.els.dialText;
                let index = 0;
                let isTyping = false;
                let currentText = "";

                if(this.dialogueTimer) clearTimeout(this.dialogueTimer);

                box.style.bottom = '50px';

                const next = () => {
                    if (isTyping) {
                        if(this.dialogueTimer) clearTimeout(this.dialogueTimer);
                        textEl.innerHTML = currentText;
                        isTyping = false;
                        return;
                    }

                    if(index >= lines.length) {
                        box.style.bottom = '-250px';
                        box.onclick = null;
                        if(onComplete) onComplete();
                        else this.inCutscene = false;
                        return;
                    }
                    const line = lines[index++];
                    nameEl.innerText = line.name;
                    textEl.innerHTML = "";
                    currentText = line.text;
                    isTyping = true;
                    
                    let charIdx = 0;
                    const type = () => {
                        if(charIdx < currentText.length) {
                            textEl.innerHTML += currentText.charAt(charIdx++);
                            this.dialogueTimer = setTimeout(type, 30);
                        } else {
                            isTyping = false;
                        }
                    };
                    type();
                };

                box.onclick = next;
                this.inCutscene = true;
                next();
            }

            runQuestLogic() {
                const lines = [];
                if(this.questState === 0) {
                    lines.push({name:'ì´Œì¥', text:"ìë„¤ê°€ ì „ì„¤ì˜ ìš©ì‚¬ì¸ê°€? ë§ˆì™•ì´ ë¶€í™œí–ˆë„¤."});
                    lines.push({name:'ì´Œì¥', text:"í•˜ì§€ë§Œ ì§€ê¸ˆì€ ë„ˆë¬´ ì•½í•´. ìì›ì„ ëª¨ì•„ 'ìƒì¸'ì—ê²Œ ê°€ì„œ ì¥ë¹„ë¥¼ ê°•í™”í•˜ê²Œ."});
                    this.questState = 1;
                    this.els.quest.innerText = "ìì› ìˆ˜ì§‘ ë° ì¥ë¹„ ê°•í™”";
                } else if(this.questState === 1) {
                    if(this.stats.jumpLevel > 1) {
                        lines.push({name:'ì´Œì¥', text:"ì˜¤! ê°•í•´ì¡Œêµ°. ì´ì œ ë¶ìª½ ìˆ²ì„ ì§€ë‚˜ ë§ˆì™•ì„±ìœ¼ë¡œ ê°€ê²Œ!"});
                        this.questState = 3;
                        this.els.quest.innerText = "ë¶ìª½ ë§ˆì™•ì„±ìœ¼ë¡œ ì´ë™!";
                    } else {
                        lines.push({name:'ì´Œì¥', text:"ì•„ì§ì¼ì„¸. ìƒì ì—ì„œ 'ì í”„ë ¥ ê°•í™”'ë¥¼ ê¼­ í•˜ê²Œë‚˜."});
                    }
                } else {
                    lines.push({name:'ì´Œì¥', text:"ë§ˆì™•ì„ ë¬¼ë¦¬ì³ì£¼ê²Œ!"});
                }
                this.startDialogue(lines);
            }

            gatherResource(obj) {
                const type = obj.userData.resType;
                if(!type) return;
                if(type === 'wood') this.resources.wood++;
                if(type === 'stone') this.resources.stone++;
                if(type === 'gem') this.resources.gem++;
                this.updateHUD();
                this.showToast(`+1 ${type.toUpperCase()}`);
                obj.position.y -= 100;
                setTimeout(() => { obj.position.y += 100; }, 5000);
            }

            shopSell() {
                if(this.resources.wood >= 5 && this.resources.stone >= 5 && this.resources.gem >= 5) {
                    this.resources.wood -= 5; this.resources.stone -= 5; this.resources.gem -= 5;
                    this.resources.gold += 50;
                    this.updateHUD();
                    this.showToast("íŒë§¤ ì™„ë£Œ (+50G)");
                } else {
                    this.showToast("ìì›ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.");
                }
            }

            shopUpgradeJump() {
                if(this.resources.gold >= 200) {
                    this.resources.gold -= 200;
                    this.stats.jumpLevel++;
                    this.updateHUD();
                    this.showToast("ì í”„ë ¥ ê°•í™” ì™„ë£Œ!");
                } else {
                    this.showToast("ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.");
                }
            }

            shopUpgradeSpeed() {
                if(this.resources.gold >= 100) {
                    this.resources.gold -= 100;
                    this.stats.speedLevel += 0.2;
                    this.updateHUD();
                    this.showToast("ì´ë™ì†ë„ ê°•í™” ì™„ë£Œ!");
                } else {
                    this.showToast("ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.");
                }
            }

            closeShop() { document.getElementById('shop-modal').style.display = 'none'; this.inCutscene = false; }
            updateHUD() {
                this.els.wood.innerText = this.resources.wood;
                this.els.stone.innerText = this.resources.stone;
                this.els.gem.innerText = this.resources.gem;
                this.els.gold.innerText = this.resources.gold;
            }
            showToast(msg) {
                const t = this.els.toast; t.innerText = msg; t.style.opacity = 1;
                setTimeout(() => t.style.opacity = 0, 2000);
            }

            setupInputs() {
                const joyZone = this.els.joystickZone;
                const joyKnob = this.els.joystickKnob;
                let joyId = null, startX=0, startY=0;

                const touchMove = document.getElementById('touch-move');
                touchMove.addEventListener('touchstart', e => {
                    e.preventDefault(); if(this.inCutscene) return;
                    const t = e.changedTouches[0]; joyId = t.identifier;
                    startX = t.clientX; startY = t.clientY;
                    joyZone.style.display = 'block';
                    joyZone.style.left = startX + 'px'; joyZone.style.top = startY + 'px';
                    joyKnob.style.transform = `translate(-50%, -50%)`;
                    this.input.x = 0; this.input.z = 0;
                }, {passive:false});

                touchMove.addEventListener('touchmove', e => {
                    e.preventDefault(); if(this.inCutscene) return;
                    for(let i=0; i<e.changedTouches.length; i++) {
                        if(e.changedTouches[i].identifier === joyId) {
                            const t = e.changedTouches[i];
                            const dx = t.clientX - startX; const dy = t.clientY - startY;
                            const dist = Math.min(Math.sqrt(dx*dx+dy*dy), 50);
                            const angle = Math.atan2(dy, dx);
                            const mx = Math.cos(angle)*dist; const my = Math.sin(angle)*dist;
                            joyKnob.style.transform = `translate(calc(-50% + ${mx}px), calc(-50% + ${my}px))`;
                            this.input.x = mx/50; this.input.z = my/50;
                        }
                    }
                }, {passive:false});

                const endJoy = (e) => {
                    for(let i=0; i<e.changedTouches.length; i++) {
                        if(e.changedTouches[i].identifier === joyId) {
                            joyId = null; joyZone.style.display = 'none';
                            this.input.x = 0; this.input.z = 0;
                        }
                    }
                };
                touchMove.addEventListener('touchend', endJoy); touchMove.addEventListener('touchcancel', endJoy);

                let lastCamX=0;
                const touchCam = document.getElementById('touch-camera');
                touchCam.addEventListener('touchstart', e => {
                    if(e.target.closest('#btn-interact')) return;
                    e.preventDefault(); lastCamX = e.changedTouches[0].clientX;
                }, {passive:false});
                touchCam.addEventListener('touchmove', e => {
                    if(e.target.closest('#btn-interact')) return;
                    e.preventDefault(); if(this.inCutscene) return;
                    const t = e.changedTouches[0];
                    const dx = t.clientX - lastCamX;
                    this.cameraState.yaw -= dx * 0.003;
                    lastCamX = t.clientX;
                }, {passive:false});

                this.els.interactBtn.addEventListener('click', (e) => { e.stopPropagation(); this.interact(); });
                this.els.interactBtn.addEventListener('touchstart', (e) => { e.stopPropagation(); this.interact(); });

                document.addEventListener('keydown', e => {
                    if(this.inCutscene) return;
                    switch(e.key.toLowerCase()) {
                        case 'w': this.input.z = -1; break;
                        case 's': this.input.z = 1; break;
                        case 'a': this.input.x = -1; break;
                        case 'd': this.input.x = 1; break;
                        case 'e': this.interact(); break;
                    }
                });
                document.addEventListener('keyup', e => {
                    if('wasd'.includes(e.key.toLowerCase())) {
                        if(['w','s'].includes(e.key.toLowerCase())) this.input.z = 0;
                        if(['a','d'].includes(e.key.toLowerCase())) this.input.x = 0;
                    }
                });
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                if (!this.inCutscene) this.updatePhysics();
                else this.ball.position.y = 2 + Math.sin(Date.now()*0.002)*0.2;

                const tx = this.ball.position.x + this.cameraState.dist * Math.cos(this.cameraState.pitch) * Math.sin(this.cameraState.yaw);
                const tz = this.ball.position.z + this.cameraState.dist * Math.cos(this.cameraState.pitch) * Math.cos(this.cameraState.yaw);
                const ty = this.ball.position.y + this.cameraState.dist * Math.sin(this.cameraState.pitch);
                this.camera.position.lerp(new THREE.Vector3(tx, ty, tz), 0.1);
                this.camera.lookAt(this.ball.position);

                this.renderer.render(this.scene, this.camera);
            }

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        const game = new Game();
    </script>
</body>
</html>
