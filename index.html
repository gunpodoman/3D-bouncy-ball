<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Bounce Ball RPG</title>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Jua', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* --- UI ë ˆì´ì–´ --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* ìì› í‘œì‹œì¤„ */
        .resource-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 25px;
            border-radius: 30px;
            color: white;
            font-size: 18px;
            backdrop-filter: blur(4px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        .res-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* ì¡°ì´ìŠ¤í‹± */
        #joystick-base {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.4);
            display: none;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }

        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        /* ìƒí˜¸ì‘ìš© ë²„íŠ¼ */
        #interaction-ui {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 15px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none; /* ë³´ì¼ ë•Œë§Œ autoë¡œ ë³€ê²½ */
        }
        
        #interaction-ui.visible {
            opacity: 1;
            pointer-events: auto;
            animation: bounceIn 0.3s;
        }

        .btn-action {
            background: #FFD700;
            border: none;
            padding: 8px 20px;
            border-radius: 8px;
            color: #333;
            font-family: 'Jua', sans-serif;
            font-size: 16px;
            cursor: pointer;
            margin-top: 5px;
            font-weight: bold;
        }

        /* ëŒ€í™”ì°½ & ìƒì  ëª¨ë‹¬ (ê³µí†µ ìŠ¤íƒ€ì¼) */
        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fff;
            padding: 25px;
            border-radius: 20px;
            width: 320px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: none;
            pointer-events: auto;
            text-align: center;
            color: #333;
            z-index: 50;
        }
        
        .modal h2 { margin-top: 0; color: #333; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        .modal p { font-size: 18px; line-height: 1.5; color: #555; }

        .shop-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #f0f0f0;
            font-size: 15px;
        }

        .btn-buy {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
        }
        .btn-buy:hover { background: #45a049; }

        .btn-close {
            margin-top: 20px;
            background: #f44336;
            color: white;
            border: none;
            padding: 10px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
        }

        /* í† ìŠ¤íŠ¸ ë©”ì‹œì§€ (ì•Œë¦¼) */
        #toast {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 10px 20px;
            border-radius: 20px;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            font-size: 16px;
            white-space: nowrap;
        }

        /* í”Œë¡œíŒ… í…ìŠ¤íŠ¸ (ìì› íšë“ ì‹œ) */
        .floating-text {
            position: absolute;
            color: #FFD700;
            font-weight: bold;
            font-size: 20px;
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
            animation: floatUp 1s forwards;
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }

        @keyframes bounceIn {
            0% { transform: translateX(-50%) scale(0.8); }
            100% { transform: translateX(-50%) scale(1); }
        }

        /* í„°ì¹˜ ì˜ì—­ */
        #touch-left { position: absolute; top: 0; left: 0; width: 50%; height: 100%; pointer-events: auto; }
        #touch-right { position: absolute; top: 0; right: 0; width: 50%; height: 100%; pointer-events: auto; }

    </style>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <!-- ìì› í‘œì‹œ -->
        <div class="resource-bar">
            <div class="res-item">ğŸªµ <span id="res-wood">0</span></div>
            <div class="res-item">ğŸª¨ <span id="res-stone">0</span></div>
            <div class="res-item">ğŸ’° <span id="res-gold">0</span></div>
        </div>

        <!-- ì•Œë¦¼ ë©”ì‹œì§€ -->
        <div id="toast">ì•Œë¦¼ ë©”ì‹œì§€</div>

        <!-- ìƒí˜¸ì‘ìš© ë²„íŠ¼ -->
        <div id="interaction-ui">
            <div id="interaction-text">NPC ì´ë¦„</div>
            <button class="btn-action" id="btn-interact">ëŒ€í™”í•˜ê¸°</button>
        </div>

        <!-- ì¡°ì´ìŠ¤í‹± -->
        <div id="joystick-base">
            <div id="joystick-knob"></div>
        </div>

        <!-- í„°ì¹˜ ì…ë ¥ ì˜ì—­ -->
        <div id="touch-left"></div>
        <div id="touch-right"></div>
    </div>

    <!-- ëŒ€í™”ì°½ ëª¨ë‹¬ -->
    <div id="dialogue-modal" class="modal">
        <h2 id="dialogue-name">NPC</h2>
        <p id="dialogue-text">ëŒ€í™” ë‚´ìš©</p>
        <button class="btn-close" onclick="game.closeDialogue()">í™•ì¸</button>
    </div>

    <!-- ìƒì  ëª¨ë‹¬ -->
    <div id="shop-modal" class="modal">
        <h2>ğŸ› ï¸ ìˆ²ì† ìƒì </h2>
        <div class="shop-item">
            <span>ğŸªµğŸª¨ ìì› íŒë§¤ (ê° 5ê°œ â†’ 10G)</span>
            <button class="btn-buy" onclick="game.sellResources()">íŒë§¤</button>
        </div>
        <div class="shop-item">
            <span>ğŸš€ ì í”„ë ¥ ê°•í™” (50G)</span>
            <button class="btn-buy" onclick="game.upgradeJump()">ê°•í™”</button>
        </div>
        <div class="shop-item">
            <span>âš¡ ì´ë™ì†ë„ ê°•í™” (50G)</span>
            <button class="btn-buy" onclick="game.upgradeSpeed()">ê°•í™”</button>
        </div>
        <button class="btn-close" onclick="game.closeShop()">ë‹«ê¸°</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        class Game {
            constructor() {
                this.config = {
                    gravity: 0.015,
                    bounceForce: 0.35,
                    moveSpeed: 0.12,
                    ballRadius: 0.4
                };
                
                this.resources = { wood: 0, stone: 0, gold: 0 };
                
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.ball = null;
                this.ballShadow = null;
                
                this.objects = []; // ë¬¼ë¦¬ ì¶©ëŒì²´ ëª©ë¡
                this.interactables = []; // ìƒí˜¸ì‘ìš©(NPC) ëª©ë¡
                this.particles = [];
                this.floatingTexts = [];
                
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.input = { x: 0, z: 0 };
                this.cameraState = { yaw: 0, pitch: 0.6, dist: 12 };
                
                this.isPlaying = false;
                this.activeNPC = null;

                // DOM Elements
                this.uiWood = document.getElementById('res-wood');
                this.uiStone = document.getElementById('res-stone');
                this.uiGold = document.getElementById('res-gold');
                this.interactionUI = document.getElementById('interaction-ui');
                this.interactionText = document.getElementById('interaction-text');
                this.shopModal = document.getElementById('shop-modal');
                this.dialogueModal = document.getElementById('dialogue-modal');
                this.toastEl = document.getElementById('toast');
                
                this.joystickBase = document.getElementById('joystick-base');
                this.joystickKnob = document.getElementById('joystick-knob');
                
                // ìƒì„±ìì—ì„œ initì„ í˜¸ì¶œí•˜ì—¬ ì´ˆê¸°í™” ì‹œì‘
                this.init();
            }

            init() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 20, 80);

                // Camera
                this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('game-container').appendChild(this.renderer.domElement);

                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
                dirLight.position.set(20, 40, 20);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                dirLight.shadow.camera.left = -40;
                dirLight.shadow.camera.right = 40;
                dirLight.shadow.camera.top = 40;
                dirLight.shadow.camera.bottom = -40;
                this.scene.add(dirLight);

                this.createPlayer();
                this.generateWorld();
                this.setupInputs();
                
                window.addEventListener('resize', () => this.onResize());
                document.getElementById('btn-interact').addEventListener('click', () => this.interact());

                // ì¦‰ì‹œ ê²Œì„ ì‹œì‘
                this.isPlaying = true;
                this.showToast("ê²Œì„ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤! ìì›ì„ ëª¨ì•„ë³´ì„¸ìš”.");
                
                this.animate();
            }

            createPlayer() {
                const geo = new THREE.SphereGeometry(this.config.ballRadius, 32, 32);
                const mat = new THREE.MeshPhongMaterial({ color: 0xFF4500 });
                this.ball = new THREE.Mesh(geo, mat);
                this.ball.position.set(0, 5, 0);
                this.ball.castShadow = true;
                this.scene.add(this.ball);

                const shadowGeo = new THREE.CircleGeometry(this.config.ballRadius, 16);
                const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 });
                this.ballShadow = new THREE.Mesh(shadowGeo, shadowMat);
                this.ballShadow.rotation.x = -Math.PI / 2;
                this.scene.add(this.ballShadow);
            }

            generateWorld() {
                // ë°”ë‹¥
                const groundGeo = new THREE.CylinderGeometry(40, 40, 10, 64);
                const groundMat = new THREE.MeshLambertMaterial({ color: 0x4CAF50 });
                const ground = new THREE.Mesh(groundGeo, groundMat);
                ground.position.y = -5;
                ground.receiveShadow = true;
                this.scene.add(ground);
                this.objects.push(ground);

                // ê±´ë¬¼
                this.createBuilding(5, 0, 5, 0x8B4513);
                this.createBuilding(-5, 0, 8, 0xA0522D);
                
                // NPC
                this.createNPC(2, 0, 2, 'shop', 'ì¡í™”ì  ì£¼ì¸');
                this.createNPC(-3, 0, -3, 'quest', 'ë§ˆì„ ì´Œì¥');

                // ë‚˜ë¬´ (30ê°œ)
                for(let i=0; i<30; i++) {
                    const angle = Math.random() * Math.PI; 
                    const dist = 10 + Math.random() * 25;
                    const x = Math.cos(angle) * dist;
                    const z = Math.sin(angle) * dist - 10;
                    this.createTree(x, 0, z);
                }

                // ë°”ìœ„ (20ê°œ)
                for(let i=0; i<20; i++) {
                    const angle = Math.random() * Math.PI + Math.PI; 
                    const dist = 10 + Math.random() * 25;
                    const x = Math.cos(angle) * dist;
                    const z = Math.sin(angle) * dist + 10; 
                    this.createRock(x, 0, z);
                }
                
                // ë¬¼
                const waterGeo = new THREE.RingGeometry(38, 100, 64);
                const waterMat = new THREE.MeshPhongMaterial({ color: 0x1E90FF, transparent: true, opacity: 0.6 });
                const water = new THREE.Mesh(waterGeo, waterMat);
                water.rotation.x = -Math.PI / 2;
                water.position.y = -0.5;
                this.scene.add(water);
            }

            createBuilding(x, y, z, color) {
                const geo = new THREE.BoxGeometry(3, 3, 3);
                const mat = new THREE.MeshLambertMaterial({ color: color });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y + 1.5, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.scene.add(mesh);
                this.objects.push(mesh);
            }

            createTree(x, y, z) {
                const group = new THREE.Group();
                group.position.set(x, y, z);
                
                // ìì› ë°ì´í„°ëŠ” ê·¸ë£¹ì— í• ë‹¹
                group.userData = { type: 'resource', resource: 'wood' };

                // ì¤„ê¸°
                const trunkGeo = new THREE.CylinderGeometry(0.3, 0.4, 1.5, 6);
                const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.y = 0.75;
                trunk.userData = { parent: group }; // ë¶€ëª¨ ì°¸ì¡°
                group.add(trunk);

                // ì
                const leavesGeo = new THREE.ConeGeometry(1.2, 2.5, 8);
                const leavesMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const leaves = new THREE.Mesh(leavesGeo, leavesMat);
                leaves.position.y = 2;
                leaves.userData = { parent: group }; // ë¶€ëª¨ ì°¸ì¡°
                group.add(leaves);

                this.scene.add(group);
                
                // ë¬¼ë¦¬ ì¶©ëŒì²´ì— ë‘ íŒŒíŠ¸ ëª¨ë‘ ì¶”ê°€ (ì–´ë””ë¥¼ ë°Ÿì•„ë„ ì±„ì§‘ë˜ë„ë¡)
                this.objects.push(trunk);
                this.objects.push(leaves);
            }

            createRock(x, y, z) {
                const geo = new THREE.DodecahedronGeometry(0.8, 0);
                const mat = new THREE.MeshLambertMaterial({ color: 0x808080 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y + 0.6, z);
                mesh.scale.set(1.5, 1, 1.5);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                mesh.userData = { type: 'resource', resource: 'stone', parent: mesh }; // ìê¸° ìì‹ ì´ ë¶€ëª¨
                this.scene.add(mesh);
                this.objects.push(mesh);
            }

            createNPC(x, y, z, role, name) {
                // r128ì—ì„œ CapsuleGeometryê°€ ì—†ìœ¼ë¯€ë¡œ Cylinderë¡œ ëŒ€ì²´
                const geo = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
                const mat = new THREE.MeshLambertMaterial({ color: role === 'shop' ? 0xFFD700 : 0xFF69B4 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y + 1, z);
                mesh.castShadow = true;
                
                const headGeo = new THREE.SphereGeometry(0.4, 8, 8);
                const headMat = new THREE.MeshLambertMaterial({ color: 0xFFE0BD });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 0.9;
                mesh.add(head);

                mesh.userData = { type: 'npc', role: role, name: name };
                this.scene.add(mesh);
                this.interactables.push(mesh);
                this.objects.push(mesh); // NPCë„ ë°Ÿê³  ì˜¬ë¼ê°ˆ ìˆ˜ ìˆìŒ
            }

            setupInputs() {
                const touchLeft = document.getElementById('touch-left');
                const touchRight = document.getElementById('touch-right');
                
                let joystickId = null;
                let startX = 0, startY = 0;

                // Joystick
                touchLeft.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if(!this.isPlaying || joystickId !== null) return;
                    const t = e.changedTouches[0];
                    joystickId = t.identifier;
                    startX = t.clientX;
                    startY = t.clientY;
                    this.joystickBase.style.display = 'block';
                    this.joystickBase.style.left = startX + 'px';
                    this.joystickBase.style.top = startY + 'px';
                    this.joystickKnob.style.transform = `translate(-50%, -50%)`;
                    this.input.x = 0; this.input.z = 0;
                }, {passive: false});

                touchLeft.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if(!this.isPlaying) return;
                    for(let i=0; i<e.changedTouches.length; i++) {
                        if(e.changedTouches[i].identifier === joystickId) {
                            const t = e.changedTouches[i];
                            const dx = t.clientX - startX;
                            const dy = t.clientY - startY;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            const maxDist = 40;
                            let moveX = dx, moveY = dy;
                            if(dist > maxDist) {
                                const angle = Math.atan2(dy, dx);
                                moveX = Math.cos(angle) * maxDist;
                                moveY = Math.sin(angle) * maxDist;
                            }
                            this.joystickKnob.style.transform = `translate(calc(-50% + ${moveX}px), calc(-50% + ${moveY}px))`;
                            this.input.x = moveX / maxDist;
                            this.input.z = moveY / maxDist;
                            break;
                        }
                    }
                }, {passive: false});

                const endJoystick = (e) => {
                    e.preventDefault();
                    for(let i=0; i<e.changedTouches.length; i++) {
                        if(e.changedTouches[i].identifier === joystickId) {
                            joystickId = null;
                            this.joystickBase.style.display = 'none';
                            this.input.x = 0; this.input.z = 0;
                            break;
                        }
                    }
                };
                touchLeft.addEventListener('touchend', endJoystick);
                touchLeft.addEventListener('touchcancel', endJoystick);

                // Camera
                let lastCamX = 0, lastCamY = 0;
                touchRight.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if(!this.isPlaying) return;
                    lastCamX = e.changedTouches[0].clientX;
                    lastCamY = e.changedTouches[0].clientY;
                }, {passive: false});

                touchRight.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if(!this.isPlaying) return;
                    const t = e.changedTouches[0];
                    const dx = t.clientX - lastCamX;
                    const dy = t.clientY - lastCamY;
                    this.rotateCamera(dx * 2, dy * 2);
                    lastCamX = t.clientX;
                    lastCamY = t.clientY;
                }, {passive: false});

                // PC Controls
                document.addEventListener('keydown', (e) => {
                    if(!this.isPlaying) return;
                    switch(e.key.toLowerCase()) {
                        case 'w': case 'arrowup': this.input.z = -1; break;
                        case 's': case 'arrowdown': this.input.z = 1; break;
                        case 'a': case 'arrowleft': this.input.x = -1; break;
                        case 'd': case 'arrowright': this.input.x = 1; break;
                        case 'e': this.interact(); break;
                    }
                });
                document.addEventListener('keyup', (e) => {
                    switch(e.key.toLowerCase()) {
                        case 'w': case 's': case 'arrowup': case 'arrowdown': this.input.z = 0; break;
                        case 'a': case 'd': case 'arrowleft': case 'arrowright': this.input.x = 0; break;
                    }
                });

                let isMouseDown = false;
                document.addEventListener('mousedown', (e) => {
                    if(!this.isPlaying || e.target.tagName === 'BUTTON') return;
                    if (!('ontouchstart' in window)) {
                        isMouseDown = true;
                        lastCamX = e.clientX;
                        lastCamY = e.clientY;
                    }
                });
                document.addEventListener('mousemove', (e) => {
                    if(isMouseDown) {
                        this.rotateCamera(e.clientX - lastCamX, e.clientY - lastCamY);
                        lastCamX = e.clientX;
                        lastCamY = e.clientY;
                    }
                });
                document.addEventListener('mouseup', () => isMouseDown = false);
            }

            rotateCamera(dx, dy) {
                const sensitivity = 0.003;
                this.cameraState.yaw -= dx * sensitivity;
                this.cameraState.pitch = Math.max(0.1, Math.min(Math.PI/2 - 0.1, this.cameraState.pitch + dy * sensitivity));
            }

            updatePhysics() {
                // Gravity
                this.velocity.y -= this.config.gravity;
                this.ball.position.add(this.velocity);

                // Move
                const camAngle = this.cameraState.yaw;
                const targetVX = (this.input.x * Math.cos(camAngle) + this.input.z * Math.sin(camAngle)) * this.config.moveSpeed;
                const targetVZ = (this.input.x * -Math.sin(camAngle) + this.input.z * Math.cos(camAngle)) * this.config.moveSpeed;
                this.velocity.x += (targetVX - this.velocity.x) * 0.1;
                this.velocity.z += (targetVZ - this.velocity.z) * 0.1;

                // Collision
                const raycaster = new THREE.Raycaster();
                raycaster.set(this.ball.position, new THREE.Vector3(0, -1, 0));
                
                const intersects = raycaster.intersectObjects(this.objects);
                let shadowY = -100;

                if (intersects.length > 0) {
                    const hit = intersects[0];
                    shadowY = hit.point.y + 0.05;

                    if (hit.distance < this.config.ballRadius && this.velocity.y < 0) {
                        this.velocity.y = this.config.bounceForce;
                        this.ball.position.y = hit.point.y + this.config.ballRadius;
                        
                        this.ball.scale.set(1.3, 0.7, 1.3);
                        setTimeout(() => this.ball.scale.set(1, 1, 1), 100);
                        
                        // Check Resource
                        // hit.object might be a child mesh, we need userData from it or its parent
                        let target = hit.object;
                        if (!target.userData.type && target.userData.parent) {
                            target = target.userData.parent;
                        }
                        
                        if (target.userData.type === 'resource') {
                            this.gatherResource(target, hit.object);
                        }
                    }
                }
                
                this.ballShadow.position.set(this.ball.position.x, shadowY, this.ball.position.z);
                this.ballShadow.visible = shadowY > -10;

                if (this.ball.position.y < -5) {
                    this.ball.position.set(0, 10, 0);
                    this.velocity.set(0, 0, 0);
                    this.showToast("ë¬¼ì— ë¹ ì ¸ì„œ ë§ˆì„ë¡œ ëŒì•„ì™”ìŠµë‹ˆë‹¤.");
                }

                this.checkNPCs();

                this.ball.rotation.x -= this.velocity.z * 1.5;
                this.ball.rotation.z += this.velocity.x * 1.5;
            }

            gatherResource(groupOrMesh, hitMesh) {
                const type = groupOrMesh.userData.resource;
                
                // íŒŒí‹°í´
                this.createExplosion(this.ball.position, type === 'wood' ? 0x8B4513 : 0x808080);
                this.createFloatingText(this.ball.position, type === 'wood' ? "+1 ë‚˜ë¬´" : "+1 ëŒ");

                if (type === 'wood') {
                    this.resources.wood++;
                    this.uiWood.innerText = this.resources.wood;
                } else if (type === 'stone') {
                    this.resources.stone++;
                    this.uiStone.innerText = this.resources.stone;
                }

                // ì¼ì‹œì ìœ¼ë¡œ ì œê±°
                this.scene.remove(groupOrMesh);
                
                // ë¬¼ë¦¬ ì¶©ëŒì²´ ëª©ë¡ì—ì„œ ì œê±° (ê·¸ë£¹ì¸ ê²½ìš° ìì‹ë“¤ì„ ëª¨ë‘ ì°¾ì•„ ì œê±°í•´ì•¼ í•¨)
                // hitMeshëŠ” ì‹¤ì œë¡œ ë¶€ë”ªíŒ ë…€ì„ì´ì§€ë§Œ, ë‚˜ë¬´ì˜ ê²½ìš° ì¤„ê¸°ì™€ ì ëª¨ë‘ ì œê±°í•´ì•¼ í•¨.
                // í¸ì˜ìƒ ê·¸ë£¹ ë‚´ë¶€ì˜ ëª¨ë“  ë©”ì‰¬ë¥¼ objectsì—ì„œ ëºŒ
                let childrenToRemove = [];
                groupOrMesh.traverse((child) => {
                    if (child.isMesh && this.objects.includes(child)) {
                        childrenToRemove.push(child);
                    }
                });
                // ë§Œì•½ groupOrMesh ìì²´ê°€ ë©”ì‰¬ë¼ë©´
                if (groupOrMesh.isMesh && this.objects.includes(groupOrMesh)) {
                    childrenToRemove.push(groupOrMesh);
                }

                this.objects = this.objects.filter(obj => !childrenToRemove.includes(obj));

                // ë¦¬ì  
                setTimeout(() => {
                    this.scene.add(groupOrMesh);
                    childrenToRemove.forEach(child => this.objects.push(child));
                }, 5000);
            }

            checkNPCs() {
                let nearNPC = null;
                for(let obj of this.interactables) {
                    if(obj.userData.type === 'npc') {
                        const dist = this.ball.position.distanceTo(obj.position);
                        if(dist < 3) {
                            nearNPC = obj;
                            break;
                        }
                    }
                }

                if(nearNPC !== this.activeNPC) {
                    this.activeNPC = nearNPC;
                    if(nearNPC) {
                        this.interactionText.innerText = nearNPC.userData.name;
                        this.interactionUI.classList.add('visible');
                    } else {
                        this.interactionUI.classList.remove('visible');
                    }
                }
            }

            interact() {
                if(!this.activeNPC) return;
                const data = this.activeNPC.userData;

                if(data.role === 'shop') {
                    this.shopModal.style.display = 'block';
                    this.isPlaying = false;
                } else {
                    document.getElementById('dialogue-name').innerText = data.name;
                    document.getElementById('dialogue-text').innerText = "ì•ˆë…•! ìˆ²ê³¼ ê´‘ì‚°ì—ì„œ ìì›ì„ ëª¨ì•„ì˜¤ë©´ ìƒì ì—ì„œ ì¢‹ì€ ë¬¼ê±´ìœ¼ë¡œ ë°”ê¿”ì¤„ê²Œ!";
                    this.dialogueModal.style.display = 'block';
                    this.isPlaying = false;
                }
            }

            sellResources() {
                if(this.resources.wood >= 5 && this.resources.stone >= 5) {
                    this.resources.wood -= 5;
                    this.resources.stone -= 5;
                    this.resources.gold += 10;
                    this.updateUI();
                    this.showToast("ìì›ì„ íŒ”ì•„ 10ê³¨ë“œë¥¼ ì–»ì—ˆìŠµë‹ˆë‹¤!");
                } else {
                    this.showToast("ë‚˜ë¬´ì™€ ëŒì´ 5ê°œì”© í•„ìš”í•©ë‹ˆë‹¤.");
                }
            }

            upgradeJump() {
                if(this.resources.gold >= 50) {
                    this.resources.gold -= 50;
                    this.config.bounceForce += 0.05;
                    this.updateUI();
                    this.showToast("ì í”„ë ¥ì´ ê°•í™”ë˜ì—ˆìŠµë‹ˆë‹¤!");
                } else {
                    this.showToast("ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.");
                }
            }

            upgradeSpeed() {
                if(this.resources.gold >= 50) {
                    this.resources.gold -= 50;
                    this.config.moveSpeed += 0.02;
                    this.updateUI();
                    this.showToast("ì´ë™ì†ë„ê°€ ë¹¨ë¼ì¡ŒìŠµë‹ˆë‹¤!");
                } else {
                    this.showToast("ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.");
                }
            }

            closeShop() {
                this.shopModal.style.display = 'none';
                this.isPlaying = true;
                this.input.x = 0; this.input.z = 0;
            }

            closeDialogue() {
                this.dialogueModal.style.display = 'none';
                this.isPlaying = true;
            }

            updateUI() {
                this.uiWood.innerText = this.resources.wood;
                this.uiStone.innerText = this.resources.stone;
                this.uiGold.innerText = this.resources.gold;
            }

            showToast(msg) {
                this.toastEl.innerText = msg;
                this.toastEl.style.opacity = 1;
                setTimeout(() => { this.toastEl.style.opacity = 0; }, 2000);
            }

            createExplosion(pos, color) {
                const count = 5;
                for(let i=0; i<count; i++) {
                    const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                    const mat = new THREE.MeshBasicMaterial({ color: color });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.copy(pos);
                    mesh.userData = { 
                        vel: new THREE.Vector3((Math.random()-0.5)*0.3, Math.random()*0.3, (Math.random()-0.5)*0.3),
                        life: 1.0 
                    };
                    this.scene.add(mesh);
                    this.particles.push(mesh);
                }
            }

            createFloatingText(pos, text) {
                const div = document.createElement('div');
                div.className = 'floating-text';
                div.innerText = text;
                
                // 3D ìœ„ì¹˜ë¥¼ 2D í™”ë©´ ì¢Œí‘œë¡œ ë³€í™˜
                const vector = pos.clone();
                vector.project(this.camera);
                
                const x = (vector.x * .5 + .5) * window.innerWidth;
                const y = (-(vector.y * .5) + .5) * window.innerHeight;
                
                div.style.left = `${x}px`;
                div.style.top = `${y}px`;
                
                document.getElementById('ui-layer').appendChild(div);
                
                setTimeout(() => div.remove(), 1000);
            }

            updateParticles() {
                for(let i=this.particles.length-1; i>=0; i--) {
                    const p = this.particles[i];
                    p.position.add(p.userData.vel);
                    p.userData.life -= 0.05;
                    p.scale.setScalar(p.userData.life);
                    if(p.userData.life <= 0) {
                        this.scene.remove(p);
                        this.particles.splice(i, 1);
                    }
                }
            }

            updateCamera() {
                const cx = this.ball.position.x + this.cameraState.dist * Math.cos(this.cameraState.pitch) * Math.sin(this.cameraState.yaw);
                const cz = this.ball.position.z + this.cameraState.dist * Math.cos(this.cameraState.pitch) * Math.cos(this.cameraState.yaw);
                const cy = this.ball.position.y + this.cameraState.dist * Math.sin(this.cameraState.pitch);

                this.camera.position.lerp(new THREE.Vector3(cx, cy, cz), 0.1);
                this.camera.lookAt(this.ball.position);
            }

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                if (this.isPlaying) {
                    this.updatePhysics();
                    this.updateParticles();
                } else {
                    if(this.ball) {
                        this.ball.position.y = 5 + Math.sin(Date.now() * 0.002) * 0.5;
                        this.ball.rotation.y += 0.01;
                    }
                }
                
                if(this.ball) this.updateCamera();
                this.renderer.render(this.scene, this.camera);
            }
        }

        const game = new Game();
    </script>
</body>
</html>
